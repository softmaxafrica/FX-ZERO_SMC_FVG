//+------------------------------------------------------------------+
//|                                                      ProjectName |
//|                                      Copyright 2020, CompanyName |
//|                                       http://www.companyname.net |
//+------------------------------------------------------------------+

#property copyright "Zero"
#property strict
#property version   "1.0"

#include <Trade/Trade.mqh>

// ======================================================================
// 1) CHART STYLE & HELPER WIDGET  — purely visual (no trading impact)
// ======================================================================
color Inp_Color_Background  = clrBlack;
color Inp_Color_Foreground  = clrWhite;
color Inp_Color_Grid        = clrGray;
color Inp_Color_BullCandle  = clrSeaGreen;
color Inp_Color_BarUp       = clrSeaGreen;
color Inp_Color_BarDown     = clrRed;
color Inp_Color_BearCandle  = clrRed;
color Inp_Color_BidLine     = clrRed;
color Inp_Color_AskLine     = clrAqua;

// ======================================================================
// 2) HTF FVG SCANNER & ZONE DISCOVERY  — controls what zones exist
// ======================================================================
string Inp_TFs             = "H1,H4";      // default scan set (kept for reference)
const int    Inp_LookbackBars    = 1000;
input int    Inp_ScanOnTimerSec  = 0;        //  (new bar only)
input bool   Inp_MergeOverlaps   = false;
input bool   Inp_ExtendToRight   = true;
input int    Inp_MaxZonesPerTF   = 500;

// Quality/Spread gates for FVGs
input int    Inp_MinPoints       = 30;        
input bool   Inp_UseATRFilter    = true;
input bool   Inp_UseATRforSpread = true;
input double Inp_MaxSpreadATRMult= 1;     
input double Inp_MaxSpreadPrice  = 0.0004;   // default (fallback abs cap)

input int    Inp_ATR_Period      = 14;
input double Inp_ATR_Mult        = 0.60;     // gap size vs ATR threshold (balanced)

// Zone life-cycle (when to consider a zone “done”)
enum EMitigation { MitigateOnTouch=0, MitigateAt50=1, MitigateFull=2 };
input EMitigation Inp_MitigationMode = MitigateAt50;
input bool   Inp_AutoRemoveOnMit = true;
input bool   Inp_ShowMidline     = true;

// Base visuals for zones/signals
input color  Inp_BullColor       = clrLime;
input color  Inp_BearColor       = clrYellow;
input int    Inp_FillAlpha       = 40;
input string Inp_ObjectPrefix    = "FVG";
input int    Inp_MaxSignalLabels = 50;
// Per-zone info labels (gap size & momentum)
input bool   Inp_ShowFVGInfo     = true;
const int    Inp_FVGInfoFontSize = 14;


// ======================================================================
// 3) TRADE ENGINE — eligibility & scoring (signal generation)
// ======================================================================
enum EConfirm { Confirm_Strict=0, Confirm_Standard=1, Confirm_Aggressive=2 };
input bool     Inp_EnableSignals   = true;
input EConfirm Inp_ConfirmMode     = Confirm_Strict;
input int      Inp_SW_Pivot        = 3;
const  double   Inp_DisplacementMin = 0.5; 
input double   Inp_MaxDistATR      = 1.5;                 
input double   Inp_ScoreMin        = 0.5;                

input bool     Inp_DrawSLTP        = true;

//===HTF FILTER========================//

// ---- HTF BOS filter around the FVG (same direction as zone) ----
enum EHTF_BOS_Mode { HTF_BOS_Before=0, HTF_BOS_After=1, HTF_BOS_BeforeOrAfter=2, HTF_BOS_Both=3 };
input bool         Inp_RequireHTF_BOS        = true;          // Must see BOS on the HTF
input EHTF_BOS_Mode Inp_HTF_BOS_Mode         = HTF_BOS_BeforeOrAfter;
input int          Inp_HTF_BOS_K             = 3;             // Swing sensitivity for BOS
input int          Inp_HTF_BOS_LookbackBars  = 100;            // Search window BEFORE the FVG close bar
input int          Inp_HTF_BOS_LookaheadBars = 200;            // Search window AFTER the FVG close bar
input bool         Inp_SoftBOS               = false;         // If BOS cannot be evaluated, allow candidate

// ---- HTF Bias filter (H1 & H4) ----

// Touch/backfill rules
const bool Inp_OnlyTradeOnFreshTouch = true;
const bool Inp_DoNotTradeBackfill    = true;
const bool Inp_AllowMultiplePerZone  = false;
input bool Inp_AllowDuplicateSidePositions = true;
bool Inp_KeepSeekingAfterTouch = true;
const bool Inp_TradeOnlyVisibleZones = true; //DO NOT CHANGE THIS (keep true for best results)
const   bool Inp_FirstTouchStrict      = true;
const   bool Inp_StartOnCloseInside    = true;


// ======================================================================
// 4) RISK & POSITION SIZING — how lots are computed and bounded
// ======================================================================
enum ELotMode { Lot_Fixed=0, Lot_RiskPct=1, Lot_RiskMoney=2 };
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
input ELotMode Inp_LotMode        = Lot_RiskPct;    // % risk per trade (balanced)

input double   Inp_FixedLots      = 0.02;         // unused in this preset
input bool     Inp_RiskUseEquity  = true;
input double   Inp_RiskMoney      = 30.0;         // not used when Lot_RiskPct
input double   Inp_LotsMin        = 0.02;
input double   Inp_LotsMax        = 0.02;
input bool     Inp_DebugLotSizing = true;
input bool     Inp_BlockWhenCapped= false;

// Legacy + SL padding
const double   Inp_RiskPerTradePct = 1;         // 0 to disable the hard cap (legacy)
input double   Inp_MaxSpreadPoints = 300;
input double   Inp_SL_Pad_SpreadMult = 5.0;

// Debug/HUD
const bool     Inp_DebugPanel      = true;
const bool     Inp_LogToJournal    = true;
const bool     Inp_UsePackedMagic  = true;   // encode confirmations/BOS into magic id
input bool     Inp_SaveOpsToText   = true;   // mirror operations/events to a plain text log


// ======================================================================
// 5) SESSION FILTER — when trading is allowed (server time / UTC)
// ======================================================================
const bool Inp_UseSessionFilter          = false;
const int  Inp_Session_TZ_Offset_Hours   = 3;
const bool Inp_Session_Allow_London      = true;
const int  Inp_London_Start_Hour         = 08;
const int  Inp_London_End_Hour           = 13;
const bool Inp_Session_Allow_NY_FirstHalf= true;
const int  Inp_NY1_Start_Hour            = 15;
const int  Inp_NY1_End_Hour              = 20;

// Session visuals
const color           Inp_SessionColor_Asia   = clrRed;
const color           Inp_SessionColor_London = clrGreen;
const color           Inp_SessionColor_NY1    = clrYellow;
const int             Inp_SessionLineWidth    = 1;
const ENUM_LINE_STYLE Inp_SessionLineStyle    = STYLE_DASH;

// Hours interpretation
const bool Inp_Session_Hours_Are_UTC = true;

// Asia (optional)
const bool Inp_Session_Allow_Asia    = true;
const int  Inp_Asia_Start_Hour       = 2;
const int  Inp_Asia_End_Hour         = 6;


// ======================================================================
// 5b) NEWS BLOCKER — simple US high-impact schedule (local file or CSV)
// ======================================================================
const bool   Inp_EnableNewsBlock        = true;     // Master ON/OFF
const int    Inp_News_Block_Minutes     = 60;       // Block window on both sides
const bool   Inp_News_Times_Are_UTC     = true;     // Interpret inputs as UTC times
const int    Inp_News_TZ_Offset_Hours   = 3;        // If not UTC, offset vs UTC (e.g., +3 for EAT)
input string Inp_News_Times_CSV         = "";       // Semicolon list: "YYYY-MM-DD HH:MM;YYYY-MM-DD HH:MM;..."
input string Inp_News_FileName          = "US_HighImpact.txt"; // Files/US_HighImpact.txt one datetime per line

// ======================================================================
// 6) SIGNAL VISUALS & LABEL HYGIENE — how signals are drawn
// ======================================================================
const bool Inp_ShowLabels        = false;
const bool Inp_ShowArrows        = false;
input int  Inp_MaxSignalsOnChart = 100;
input int  Inp_SignalKeepBars    = 200;
const int  Inp_LabelYStepPoints  = 55;
const int  Inp_LabelWrapChars    = 100;
const int  Inp_LabelLineStepPoints = 1200; // min vertical distance between labels (points)
input bool Inp_ShowTradeExecLabels = true;

enum ELabelDetail { Label_Off=0, Label_Basic=1, Label_Full=2 };
input ELabelDetail Inp_LabelDetail = Label_Full;
input bool        Inp_LogOnlyTrades= false;


// ======================================================================
// 7) ORDER ENTRY & RISK/REWARD TARGETS — how orders are sent
// ======================================================================
enum EEntryMode { Entry_Market=0, Entry_PendingAtEntry=1 };
const EEntryMode  Inp_EntryMode  = Entry_Market;

const bool        Inp_TradeLive        = true;

const  bool   Inp_UseDailyLossStop = false;
const  double Inp_DailyLossMaxPct  = 3.0;

// Weekend protection: block new entries after Friday cutoff and flatten before weekend
input bool Inp_WeekendProtect     = true;   // Enforce weekend rules
input int  Inp_Friday_CutoffHour  = 19;     // Do NOT open new positions after Friday 19:00 (server time)
input int  Inp_Friday_FlattenHour = 23;     // Close open positions/cancel pendings from Friday 21:00
const bool Inp_MondayProtect     = true;   // Block trading before Monday 08:00 AM
const int  Inp_Monday_CutoffHour  = 8;      // Do NOT open new positions before Monday 08:00 (server time)
const bool Inp_RequireHTF_Liq_Sweep  = false;   
input int         Inp_PendingExpiryMin = 0;


const long        Inp_Magic            = 660001;

// Fixed TP targets (always computed)
const double Inp_RR_TP1 = 3.0;
input double Inp_RR_TP2 = 5.0;
enum ETPForOrder { Use_TP1=0, Use_TP2=1, Use_None=2 };
const ETPForOrder Inp_OrderTP = Use_TP1;

// Conflict handling on fresh signal
input bool   Inp_CloseOppositeOnSignal   = true;
input bool   Inp_CloseOpp_OnlyIfProfit   = true;
input double Inp_CloseOpp_MinProfitMoney = 20.0;
input bool   Inp_CancelOppositePendings  = true;


// ======================================================================
// 8) EXIT MANAGEMENT — fixed TPs OR BE+trail (choose one mode)
// ======================================================================
enum EExitMode { Exit_FixedTPs=0, Exit_BE_Trail=1 };
const EExitMode Inp_ExitMode       = Exit_BE_Trail;  // trailing with delayed BE

// BE/Trail parameters (used only if Exit_BE_Trail)
const double Inp_BE_Trig_R    = 1.0;   // BE later to avoid scratches on indices
const double Inp_Trail_Trig_R = 2.0;   // start trailing a bit later
const int    Inp_Trail_SwingK = 3;


// ======================================================================
// 9) CUSTOM CONFIRMATION ENGINE — K-of-N or Pairs
// ======================================================================
const bool Inp_UI_UseStructured = true; //Keep It True For Pair Or K of N to work

// K-of-N toggles (enable what you want), then choose K
const bool Inp_UI_Confirm_ENGULF = true;
const bool Inp_UI_Confirm_MFVG   = true;
const bool Inp_UI_Confirm_WICK   = true;
const bool Inp_UI_Confirm_BOS    = true;
const bool Inp_UI_Confirm_SFP    = true;
const bool Inp_UI_Confirm_RETEST = true;
const bool Inp_UI_Confirm_IB     = true;
const int  Inp_UI_Confirm_K      = 3;       


enum EConfirmation { CONF_ENGULF=0, CONF_MFVG=1, CONF_WICK=2, CONF_BOS=3, CONF_SFP=4, CONF_RETEST=5, CONF_IB=6, CONF_NONE=7 };
const bool          Inp_UI_UsePairs          = true;  // If True AB Pairs instead of K-of-N
const bool          Inp_ConfirmPair1_Enable  = true;
// const EConfirmation Inp_ConfirmPair1_A       = CONF_BOS;
// const EConfirmation Inp_ConfirmPair1_B       = CONF_MFVG;
// const bool          Inp_ConfirmPair2_Enable  = true;
// const EConfirmation Inp_ConfirmPair2_A       = CONF_RETEST;
// const EConfirmation Inp_ConfirmPair2_B       = CONF_ENGULF;
// const bool          Inp_ConfirmPair3_Enable  = true;
// const EConfirmation Inp_ConfirmPair3_A       = CONF_BOS;
// const EConfirmation Inp_ConfirmPair3_B       = CONF_SFP;
// const bool          Inp_ConfirmPair4_Enable  = true;
// const EConfirmation Inp_ConfirmPair4_A       = CONF_BOS;
// const EConfirmation Inp_ConfirmPair4_B       = CONF_RETEST;
// const bool          Inp_ConfirmPair5_Enable  = true;
// const EConfirmation Inp_ConfirmPair5_A       = CONF_BOS;
// const EConfirmation Inp_ConfirmPair5_B       = CONF_IB;
// const bool          Inp_ConfirmPair6_Enable  = true;
// const EConfirmation Inp_ConfirmPair6_A       = CONF_ENGULF;
// const EConfirmation Inp_ConfirmPair6_B       = CONF_SFP;


const EConfirmation Inp_ConfirmPair1_A       = CONF_BOS;
const EConfirmation Inp_ConfirmPair1_B       = CONF_ENGULF;
const bool          Inp_ConfirmPair2_Enable  = true;
const EConfirmation Inp_ConfirmPair2_A       = CONF_RETEST;
const EConfirmation Inp_ConfirmPair2_B       = CONF_ENGULF;
const bool          Inp_ConfirmPair3_Enable  = true;
const EConfirmation Inp_ConfirmPair3_A       = CONF_SFP;
const EConfirmation Inp_ConfirmPair3_B       = CONF_BOS;
const bool          Inp_ConfirmPair4_Enable  = true;
const EConfirmation Inp_ConfirmPair4_A       = CONF_RETEST;
const EConfirmation Inp_ConfirmPair4_B       = CONF_MFVG;
const bool          Inp_ConfirmPair5_Enable  = true;
const EConfirmation Inp_ConfirmPair5_A       = CONF_SFP;
const EConfirmation Inp_ConfirmPair5_B       = CONF_ENGULF;
const bool          Inp_ConfirmPair6_Enable  = true;
const EConfirmation Inp_ConfirmPair6_A       = CONF_BOS;
const EConfirmation Inp_ConfirmPair6_B       = CONF_MFVG;


// ======================================================================
// 10) LTF CHILD-TF MAPPING (for BOS checks on lower TF)
// ======================================================================
input ENUM_TIMEFRAMES Inp_BOS_Child_M5  = PERIOD_M3;
input ENUM_TIMEFRAMES Inp_BOS_Child_M15 = PERIOD_M3;
input ENUM_TIMEFRAMES Inp_BOS_Child_M1 = PERIOD_M1;


// Additional eligibility filters & visual backfill
input bool Inp_RequireLocation = true;    // (discount/premium filter)
input int  Inp_BackfillBars    = 300;    //(visual backfill only)

// === User-selectable child BOS timeframes ===
input ENUM_TIMEFRAMES Inp_BOS_Child_H1 = PERIOD_M3;   // Child TF for H1 FVG BOS
input ENUM_TIMEFRAMES Inp_BOS_Child_H4 = PERIOD_M5;   // Child TF for H4 FVG BOS


// ======================================================================
// 11) GLOBALS (runtime state & object names) — DO NOT EDIT IN INPUTS
// ======================================================================

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool isVisual   = (bool)MQLInfoInteger(MQL_VISUAL_MODE);
bool isOptim    = (bool)MQLInfoInteger(MQL_OPTIMIZATION);

// --- LTF eval override for confirmations (keeps code changes minimal)
bool            g_evalOverride = false;
ENUM_TIMEFRAMES g_evalTF       = PERIOD_CURRENT;   // target LTF when override=true
int             g_ftShiftActive = -1;              // when >=1, confirmations may not reference bars older than this shift (post-touch gating)

// ========== SIMPLE OPERATIONS TEXT LOGGER ==========
string OpsTxtName() { return StringFormat("ZERO_OPS_%s.txt", _Symbol); }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OpsLog(const string line)
  {
   if(!Inp_SaveOpsToText)
      return;
   int h = FileOpen(OpsTxtName(), FILE_READ|FILE_WRITE|FILE_TXT|FILE_SHARE_READ);
   if(h==INVALID_HANDLE)
      h = FileOpen(OpsTxtName(), FILE_WRITE|FILE_TXT|FILE_SHARE_READ);
   if(h==INVALID_HANDLE)
      return;
   FileSeek(h, 0, SEEK_END);
   string t = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
   FileWriteString(h, t + " | " + line + "\r\n");
   FileFlush(h);
   FileClose(h);
  }

// Getter used inside confirmation helpers instead of TF_LTF()
// Correct: fall back to the chart TF when override=false
inline ENUM_TIMEFRAMES TF_LTF() { return g_evalOverride ? g_evalTF : (ENUM_TIMEFRAMES)_Period; }

// (Help panel removed)

// When TRUE: SpawnSignalAt() only draws; ExecuteTradeForSignal() no-ops
bool g_suppressAutoTrade = false;

// --- simple in-memory schedule for US high-impact news times (server time)
datetime g_newsTimes[];
bool     g_newsLoaded = false;

// Excel auto-open state
// (CSV/text logging removed)


// ======================================================================
// 12) TYPES & STATE (reserved section header; your structs live below)
// ======================================================================
// (keep your struct/arrays/state definitions here)



struct SwingPt { int idx; double price; bool isHigh; };

struct Candidate
  {
   bool              valid;
   bool              is_buy;
   ENUM_TIMEFRAMES   htf;
   datetime          t1;
   double            top, bot, mid;
   double            disp;
   bool              swept;
   int               biasH1;
   int               biasH4;
   bool              inLocation;
   double            score;
   // NEW: HTF BOS info
   bool              bosBefore;
   bool              bosAfter;
   double            bosRefLevel;   // the swing level that was/should be broken
  };

struct Signal
  {
   string            id;
   bool              is_buy;
   ENUM_TIMEFRAMES   htf;
   datetime          when;
   double            entry, sl, tp1, tp2;
   string            confirm;
   string            info;
   bool              drawn;
   bool              traded;
   ulong             ticket;
   datetime          z_t1;
   double            z_top, z_bot;
   double            z_disp;
  };

Signal g_signals[];
datetime g_lastLTFClosed = 0;

//==================== HTF OVERLAY ====================//
enum EHTFMode { HTF_H1_M5=0, HTF_H4_M15=1, HTF_BOTH=2, HTF_ANY=3, HTF_M15_M1=4 };
input EHTFMode Inp_HTFMode          = HTF_H1_M5; // Trade H1 & H4 by default
input int      Inp_CleanFVG_AfterHours = 0;
input bool     Inp_DrawHTF_Midline  = true;
input color    Inp_H1_BuyColor      = clrAqua;
input color    Inp_H1_SellColor     = clrOrangeRed;
input color    Inp_H4_BuyColor      = clrGreen;
input color    Inp_H4_SellColor     = clrMagenta;

//==================== FVG ZONE TYPE ====================//
struct FVGZone
  {
   long              id;
   ENUM_TIMEFRAMES   tf;
   bool              bullish;
   datetime          t_left;
   datetime          t_right;
   double            lower;
   double            upper;
   bool              active;
   string            name;
   string            name50;
   datetime          created;
  };

CTrade Trade;

//==================== STATE ====================//
#define MAX_TF 10

ENUM_TIMEFRAMES g_tfs[MAX_TF];
int             g_tf_count = 0;

// Set g_tfs[] and g_tf_count based on Inp_HTFMode
void SetHTFMode()
{
   g_tf_count = 0;
   switch(Inp_HTFMode)
   {
      case HTF_H1_M5:
         g_tfs[0] = PERIOD_H1;
         g_tf_count = 1;
         break;
      case HTF_H4_M15:
         g_tfs[0] = PERIOD_H4;
         g_tf_count = 1;
         break;
      case HTF_BOTH:
         g_tfs[0] = PERIOD_H1;
         g_tfs[1] = PERIOD_H4;
         g_tf_count = 2;
         break;
      case HTF_M15_M1:
         g_tfs[0] = PERIOD_M15;
         g_tf_count = 1;
         break;
      case HTF_ANY:
      default:
         g_tfs[0] = PERIOD_M15;
         g_tfs[1] = PERIOD_H1;
         g_tfs[2] = PERIOD_H4;
         g_tf_count = 3;
         break;
   }
}

datetime        g_last_right_time[MAX_TF];
long            g_next_id = 1;

FVGZone         g_zones[];
int             g_zone_count = 0;

// retired memory (prevents redraw)
struct RetiredZone { ENUM_TIMEFRAMES tf; bool is_buy; datetime t1; double top; double bot; };
RetiredZone g_retired[];

// === ZONE EXPIRY INPUT ===
const int Inp_ZoneExpiryHours = 0; // Inp_ZoneExpiryHours (0 = never expire)

// for quick comparisons
struct HTFSeen
  {
   bool              inited;
   bool              retired;
   datetime          t1;
   double            top, bot;
  };
HTFSeen g_htf[2][2]; // [0=H1,1=H4][0=BUY,1=SELL]

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int TFSlot(ENUM_TIMEFRAMES tf) { return (tf==PERIOD_H1)?0:1; }
int SideSlot(bool is_buy) { return is_buy?0:1; }

// --- zones we've already traded once (prevents re-trading same HTF zone) ---
struct TradedZoneKey { ENUM_TIMEFRAMES tf; bool is_buy; datetime t1; double top; double bot; };
TradedZoneKey g_tradedOnce[];

// --- zones that have FIRST-TOUCHED (validated) ---
struct ValidatedZoneKey
  {
   ENUM_TIMEFRAMES   tf;
   bool              is_buy;
   datetime          t1;
   double            top, bot;
   datetime          first_touch_time;  // LTF bar time when 1st touch happened
  };
ValidatedZoneKey g_validated[];

// ===== MAGIC ENCODING (compact, integer-only) =====
// Layout (LSB first):
//  bits 0..6  : LTF confirmations flags (ENG,MFVG,WICK,BOS,SFP,RETEST,IB)
//  bits 7..9  : Pair index (0=NA, 1..6 = pair number)
//  bits 10..11: HTF BOS type (0=NONE,1=BEFORE,2=AFTER,3=BOTH)
//  bits 12..15: reserved
//  bits 16..63: Base EA id (Inp_Magic)

#define MG_SHIFT 16
ulong MG_BASE() { return (ulong)Inp_Magic; }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool  MagicIsOurs(long mg)
  {
   ulong umg=(ulong)mg;
   return ((umg>>MG_SHIFT)==MG_BASE()) || (umg==MG_BASE());
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
ulong MagicPack(uchar flags7, uchar pairIdx, uchar bosType)
  {
   return (MG_BASE()<<MG_SHIFT) | ((ulong)(bosType & 0x3)<<10) | ((ulong)(pairIdx & 0x7)<<7) | (ulong)(flags7 & 0x7F);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
uchar MagicFlags(ulong mg)   { return (uchar)(mg & 0x7F); }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
uchar MagicPair(ulong mg)    { return (uchar)((mg>>7) & 0x7); }
uchar MagicBOSType(ulong mg) { return (uchar)((mg>>10) & 0x3); }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void BuildConfirmBits(const string &confirm, uchar &flags7, uchar &pairIdx)
  {
   flags7=0;
   pairIdx=0;
   string src = Upper(Trim(confirm));
   if(StringFind(src, "MFVG")   >=0)
      flags7 |= (1<<0);
   if(StringFind(src, "BOS")    >=0)
      flags7 |= (1<<1);
   if(StringFind(src, "RETEST") >=0)
      flags7 |= (1<<2);
   if(StringFind(src, "ENGULF") >=0)
      flags7 |= (1<<3);
   if(StringFind(src, "SFP")    >=0)
      flags7 |= (1<<4);
   if(StringFind(src, "IB")     >=0)
      flags7 |= (1<<5);
   if(StringFind(src, "WICK")   >=0)
      flags7 |= (1<<6);

// try to match a configured pair (1..6)
   int plus = StringFind(src, "+");
   if(plus>0)
     {
      string tokA = Trim(StringSubstr(src, 0, plus));
      string tokB = Trim(StringSubstr(src, plus+1));
      int confA = ConfirmTokenIndex(tokA);
      int confB = ConfirmTokenIndex(tokB);
      if(confA>=0 && confB>=0)
        {
         int a[6] = { (int)Inp_ConfirmPair1_A, (int)Inp_ConfirmPair2_A, (int)Inp_ConfirmPair3_A,
                      (int)Inp_ConfirmPair4_A, (int)Inp_ConfirmPair5_A, (int)Inp_ConfirmPair6_A
                    };
         int b[6] = { (int)Inp_ConfirmPair1_B, (int)Inp_ConfirmPair2_B, (int)Inp_ConfirmPair3_B,
                      (int)Inp_ConfirmPair4_B, (int)Inp_ConfirmPair5_B, (int)Inp_ConfirmPair6_B
                    };
         bool en[6]= { Inp_ConfirmPair1_Enable, Inp_ConfirmPair2_Enable, Inp_ConfirmPair3_Enable,
                       Inp_ConfirmPair4_Enable, Inp_ConfirmPair5_Enable, Inp_ConfirmPair6_Enable
                     };
         for(int i=0;i<6;i++)
           {
            if(!en[i])
               continue;
            if((confA==a[i] && confB==b[i]) || (confA==b[i] && confB==a[i]))
              { pairIdx=(uchar)(i+1); break; }
           }
        }
     }
  }


  
//==================== INIT/DEINIT/EVENTS ====================//

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int OnInit()
  {
   ApplyChartStyle();
   DrawSessionLines_Today_Simple();
// Preload news times (optional; also lazy-loaded on first use)
   if(Inp_EnableNewsBlock)
     {
      g_newsLoaded=false;
      LoadNewsTimes();
     }
   ConfigureTrade();
   ArrayResize(g_tradedOnce,0);
   SetHTFMode();
   for(int ti=0; ti<2; ++ti)
      for(int si=0; si<2; ++si)
        {
         g_htf[ti][si].inited=false;
         g_htf[ti][si].retired=false;
        }
   ArrayResize(g_retired,0);

// remove any old HTF boxes from earlier runs
   int tot=ObjectsTotal(0);
   for(int i=tot-1;i>=0;--i)
     {
      string nm=ObjectName(0,i);
      if(StringFind(nm,"HTF_")==0)
         ObjectDelete(0,nm);
     }

   g_lastLTFClosed = 0;
   ArrayResize(g_signals, 0);

   int total=ObjectsTotal(0);
   for(int i=total-1;i>=0;i--)
     {
      string name=ObjectName(0,i);
      if(StringFind(name, Inp_ObjectPrefix)==0)
         ObjectDelete(0,name);
     }

   ArrayResize(g_zones, 0);
   g_zone_count=0;

// (Help panel removed)
   if(Inp_ScanOnTimerSec>0)
      EventSetTimer(Inp_ScanOnTimerSec);

// CSV/text auto-open removed
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   EventKillTimer();
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
      // --- session lines: auto-roll to the new trading day ---
      if(Inp_UseSessionFilter)
      {
        static datetime lastMidnight = 0;
        MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
        dt.hour = 0; dt.min = 0; dt.sec = 0;
        datetime todayMidnight = StructToTime(dt);
        if (todayMidnight != lastMidnight)
        {
           DrawSessionLines_Today_Simple();   // uses your fixed offset math
           lastMidnight = todayMidnight;
        }
      }
   CheckMitigations();
   // Always refresh to keep info labels present and centered
   RefreshGraphics();

// Weekend flattening (close/cancel) if needed
   if(ShouldFlattenForWeekend())
      FlattenSymbolForWeekend();

   DrawHTFFVG_Extended(true);
   DrawHTFFVG_Extended(false);

   CleanupMitigatedFVGs();

   EvaluateTradeOpportunities();
   ManageOpenPositions_BE_Trail();
   TidySignalVisuals();

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,const long &l,const double &d,const string &s)
  {
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTimer()
   {
    DrawSessionLines_Today_Simple();
    SetHTFMode();
    for(int i=0;i<g_tf_count;i++)
       {
         if(NewBarOccurred(g_tfs[i], g_last_right_time[i]))
             ScanTF(g_tfs[i]);
       }
    CleanupMitigatedFVGs();
    // Ensure all active zones and their info labels are refreshed even without ticks
    RefreshGraphics();
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+


//==================== HELPERS ====================//



//==================== BE / Trailing state ====================//
struct PMState
  {
   ulong             pos_ticket;
   string            comment;
   double            entry;
   double            initialSL;
   bool              movedBE;
   bool              trailArmed;
  };
PMState g_pmStates[];

// find state by position ticket
int PM_Find(ulong ticket)
  {
   for(int i=0;i<ArraySize(g_pmStates);++i)
      if(g_pmStates[i].pos_ticket==ticket)
         return i;
   return -1;
  }

// ensure state exists for a live position (capture initial SL once)
void PM_EnsureForPosition()
  {
   for(int i=0;i<PositionsTotal();++i)
     {
      ulong pt=PositionGetTicket(i);
      if(pt==0 || !PositionSelectByTicket(pt))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if(!MagicIsOurs((long)PositionGetInteger(POSITION_MAGIC)))
         continue;

      if(PM_Find(pt)<0)
        {
         int n=ArraySize(g_pmStates);
         ArrayResize(g_pmStates,n+1);
         g_pmStates[n].pos_ticket = pt;
         g_pmStates[n].comment    = PositionGetString(POSITION_COMMENT);
         g_pmStates[n].entry      = PositionGetDouble(POSITION_PRICE_OPEN);
         double sl0               = PositionGetDouble(POSITION_SL);
         // if no SL (broker rejected), seed with entry +/- ATR to avoid div by zero
         if(sl0<=0.0)
           {
            double atr = MathMax(ATR(TF_LTF(),14), 10*_Point);
            bool is_buy = ((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY);
            sl0 = is_buy ? (g_pmStates[n].entry - atr) : (g_pmStates[n].entry + atr);
           }
         g_pmStates[n].initialSL  = sl0;
         g_pmStates[n].movedBE    = false;
         g_pmStates[n].trailArmed = false;
        }
     }
  }

//================= Zone Validation Aftor Touch /Retracements =================

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ZoneKeyEquals_V(const ValidatedZoneKey &v,
                     ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   if(v.tf!=tf || v.is_buy!=is_buy || v.t1!=t1)
      return false;
   double eps = ZoneEps(top,bot);
   return (MathAbs(v.top-top)<=eps && MathAbs(v.bot-bot)<=eps);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int FindValidatedIndex(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   for(int i=0;i<ArraySize(g_validated);++i)
      if(ZoneKeyEquals_V(g_validated[i], tf, is_buy, t1, top, bot))
         return i;
   return -1;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsZoneValidated(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot, int &firstTouchShiftOut)
  {
   firstTouchShiftOut = -1;
   int idx = FindValidatedIndex(tf,is_buy,t1,top,bot);
   if(idx<0)
      return false;

// convert stored time -> current LTF shift
   int sh = iBarShift(_Symbol, TF_LTF(), g_validated[idx].first_touch_time, true);
   if(sh<0)
      sh=1; // if the bar slid out of history window, still consider it validated
   firstTouchShiftOut = sh;
   return true;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void MarkZoneValidated(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot, int s_touch)
  {
   datetime when = iTime(_Symbol, TF_LTF(), s_touch);
   int idx = FindValidatedIndex(tf,is_buy,t1,top,bot);
   if(idx<0)
     {
      int n=ArraySize(g_validated);
      ArrayResize(g_validated,n+1);
      g_validated[n].tf=tf;
      g_validated[n].is_buy=is_buy;
      g_validated[n].t1=t1;
      g_validated[n].top=top;
      g_validated[n].bot=bot;
      g_validated[n].first_touch_time=when;
     }
   else
     {
      // keep the earlier (older in time) validation; only update if we somehow don't have a time
      if(g_validated[idx].first_touch_time==0)
         g_validated[idx].first_touch_time=when;
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void UnmarkZoneValidated(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   int idx = FindValidatedIndex(tf,is_buy,t1,top,bot);
   if(idx<0)
      return;
   for(int i=idx;i<ArraySize(g_validated)-1;++i)
      g_validated[i]=g_validated[i+1];
   ArrayResize(g_validated, ArraySize(g_validated)-1);
  }



//===============END DISCRIPTION PANEL HELPERS================


// Bar s must touch the zone, and the previous bar must be fully on the far side (i.e., this is the FIRST touch)
bool LTF_EnteredZoneThisBar(bool is_buy, double top, double bot, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+2, r, bars) || bars < s+2)
      return false;

   double hi  = r[s].high,   lo  = r[s].low;
   double phi = r[s+1].high, plo = r[s+1].low;

   bool touch_now = !(hi < bot || lo > top);
// for BUY zones (bullish FVG below): retrace down from above -> prev bar entirely above the zone
// for SELL zones (bearish FVG above): retrace up from below -> prev bar entirely below the zone
   bool prev_far  = is_buy ? (plo > top) : (phi < bot);

   return (touch_now && prev_far);
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ZoneKeyEquals(const TradedZoneKey &a,
                   ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   if(a.tf!=tf || a.is_buy!=is_buy || a.t1!=t1)
      return false;
   double eps = ZoneEps(top,bot);
   return (MathAbs(a.top-top)<=eps && MathAbs(a.bot-bot)<=eps);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsZoneAlreadyTraded(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   for(int i=0;i<ArraySize(g_tradedOnce);++i)
      if(ZoneKeyEquals(g_tradedOnce[i], tf, is_buy, t1, top, bot))
         return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void MarkZoneTraded(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
  {
   if(IsZoneAlreadyTraded(tf, is_buy, t1, top, bot))
      return;
   int n=ArraySize(g_tradedOnce);
   ArrayResize(g_tradedOnce, n+1);
   g_tradedOnce[n].tf=tf;
   g_tradedOnce[n].is_buy=is_buy;
   g_tradedOnce[n].t1=t1;
   g_tradedOnce[n].top=top;
   g_tradedOnce[n].bot=bot;
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int DigitsSym() { return (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS); }
double ND(double p) { return NormalizeDouble(p, DigitsSym()); }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double CalcLotsByRisk(double entry, double sl, double riskPct)
  {
   double bal        = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskMoney  = bal * (riskPct/100.0);

   double tickValue  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotStep    = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot     = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot     = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   if(tickValue<=0 || tickSize<=0)
      return minLot;

   double stopDist   = MathMax(MathAbs(entry - sl), tickSize);
   double ticks      = stopDist / tickSize;
   double lots       = riskMoney / (ticks * tickValue);

// normalize to step and bounds
   lots = MathFloor(lots/lotStep)*lotStep;
   lots = MathMax(minLot, MathMin(maxLot, lots));
   return lots;
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double GetSpreadPoints()
  {
   long sp=0;
   SymbolInfoInteger(_Symbol, SYMBOL_SPREAD, sp);
   return (double)sp;
  }
double GetSpreadPrice() { return GetSpreadPoints() * _Point; }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// double SpreadLimitPrice()
//   {
//    if(Inp_UseATRforSpread)
//      {
//       double atr = ATR(TF_LTF(), 14);
//       if(atr>0)
//          return atr * Inp_MaxSpreadATRMult;
//      }
// // Fallback to absolute price limit (for FX you might keep 0.0004, for indices set e.g. 3.0)
//    return Inp_MaxSpreadPrice;
//   }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double SpreadLimitPrice()
  {
   if(Inp_UseATRforSpread)
     {
      double atr=ATR(PERIOD_H1,14);
      if(atr>0)
         return atr*Inp_MaxSpreadATRMult;
     }
   return Inp_MaxSpreadPrice;
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string TFToStr(ENUM_TIMEFRAMES tf)
  {
   switch(tf)
     {
      case PERIOD_M1:
         return "M1";
      case PERIOD_M2:
         return "M2";
      case PERIOD_M3:
         return "M3";
      case PERIOD_M4:
         return "M4";
      case PERIOD_M5:
         return "M5";
      case PERIOD_M6:
         return "M6";
      case PERIOD_M10:
         return "M10";
      case PERIOD_M12:
         return "M12";
      case PERIOD_M15:
         return "M15";
      case PERIOD_M20:
         return "M20";
      case PERIOD_M30:
         return "M30";
      case PERIOD_H1:
         return "H1";
      case PERIOD_H2:
         return "H2";
      case PERIOD_H3:
         return "H3";
      case PERIOD_H4:
         return "H4";
      case PERIOD_H6:
         return "H6";
      case PERIOD_H8:
         return "H8";
      case PERIOD_H12:
         return "H12";
      case PERIOD_D1:
         return "D1";
      case PERIOD_W1:
         return "W1";
      case PERIOD_MN1:
         return "MN1";
     }
   return "TF";
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool StrToTF(string tok, ENUM_TIMEFRAMES &out)
  {
   tok = StringTrimLeft(tok);
   tok = StringTrimRight(tok);
   tok = StringToUpper(tok);

   if(tok=="M1") {
      out=PERIOD_M1;return true;}
   if(tok=="M2"){out=PERIOD_M2;return true;}if(tok=="M3"){out=PERIOD_M3;return true;}if(tok=="M4"){out=PERIOD_M4;return true;}if(tok=="M5")
     {out=PERIOD_M5;return true;}if(tok=="M6"){out=PERIOD_M6;return true;}if(tok=="M10"){out=PERIOD_M10;return true;}if(tok=="M12"){out=PERIOD_M12;return true;}if(tok=="M15"){out=PERIOD_M15;return true;}if(tok=="M20"){out=PERIOD_M20;return true;}if(tok=="M30"){out=PERIOD_M30;return true;}if(tok=="H1"){out=PERIOD_H1;return true;}if(tok=="H4"){out=PERIOD_H4;return true;}if(tok=="D1"){out=PERIOD_D1;return true;}if(tok=="W1"){out=PERIOD_W1;return true;}if(tok=="MN1"){out=PERIOD_MN1;return true;}return false;}

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
uint ColorWithAlpha(color c, int a)
  {
   if(a<0)
      a=0;
   if(a>255)
      a=255;
   return (uint)ColorToARGB(c, (uchar)a);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double Mid(double a, double b) { return (a+b)*0.5; }
int TFIndex(ENUM_TIMEFRAMES tf) { for(int i=0;i<g_tf_count;i++) if(g_tfs[i]==tf) return i; return -1; }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double ZoneEps(double top,double bot)
  {
   double h = MathMax(MathAbs(top-bot), _Point*20.0);
   return MathMax(_Point*10.0, h*0.005);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool SameZone(const HTFSeen &s, datetime t1, double top, double bot)
  {
   if(!s.inited)
      return false;
   if(s.t1!=t1)
      return false;
   double eps = ZoneEps(s.top,s.bot);
   return (MathAbs(s.top-top)<=eps && MathAbs(s.bot-bot)<=eps);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// bool IsRetired(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
//   {
//    for(int i=0;i<ArraySize(g_retired);++i)
//      {
//       if(g_retired[i].tf==tf && g_retired[i].is_buy==is_buy)
//         {
//          if(g_retired[i].t1==t1 &&
//             MathAbs(g_retired[i].top-top)<=ZoneEps(top,bot) &&
//             MathAbs(g_retired[i].bot-bot)<=ZoneEps(top,bot))
//             return true;
//         }
//      }
//    return false;
//   }

bool IsRetired(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
{
   int n = ArraySize(g_retired);
   if(n<=0) return false;

   // normalize the candidate
   double hi = MathMax(top, bot);
   double lo = MathMin(top, bot);
   double eps  = ZoneEps(hi, lo);
   int    tTol = MathMax(PeriodSeconds(tf), 60); // <= one bar or 60s

   // --- Check expiry by creation time (if enabled) ---
   if(Inp_ZoneExpiryHours > 0)
   {
      // Find the zone in g_zones to get its creation time
      for(int j=0; j<g_zone_count; ++j)
      {
         FVGZone z = g_zones[j];
         if(z.tf==tf && z.bullish==is_buy)
         {
            double zhi = MathMax(z.upper, z.lower);
            double zlo = MathMin(z.upper, z.lower);
            if(MathAbs((long)(z.t_left - t1)) <= tTol && MathAbs(zhi - hi) <= eps && MathAbs(zlo - lo) <= eps)
            {
               if(z.created > 0 && (TimeCurrent() - z.created) > (Inp_ZoneExpiryHours * 3600))
                  return true; // zone expired
            }
         }
      }
   }

   for(int i=0; i<n; ++i)
   {
      if(g_retired[i].tf!=tf || g_retired[i].is_buy!=is_buy) continue;

      // normalize stored zone too
      double rhi = MathMax(g_retired[i].top, g_retired[i].bot);
      double rlo = MathMin(g_retired[i].top, g_retired[i].bot);

      if(MathAbs((long)(g_retired[i].t1 - t1)) <= tTol &&
         MathAbs(rhi - hi) <= eps &&
         MathAbs(rlo - lo) <= eps)
         return true;
   }
   return false;
}



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// void MarkRetired(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
//   {
//    if(IsRetired(tf,is_buy,t1,top,bot))
//       return;
//    int n=ArraySize(g_retired);
//    ArrayResize(g_retired,n+1);
//    g_retired[n].tf=tf;
//    g_retired[n].is_buy=is_buy;
//    g_retired[n].t1=t1;
//    g_retired[n].top=top;
//    g_retired[n].bot=bot;
//   }

void MarkRetired(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
{
   // normalize & snap to HTF bar open so we match generation time
   double hi = ND(MathMax(top, bot));
   double lo = ND(MathMin(top, bot));

   int sh = iBarShift(_Symbol, tf, t1, true);
   datetime t1n = (sh>=0 ? iTime(_Symbol, tf, sh) : t1);

   if(IsRetired(tf, is_buy, t1n, hi, lo))
      return;

   int n = ArraySize(g_retired);
   ArrayResize(g_retired, n+1);
   g_retired[n].tf    = tf;
   g_retired[n].is_buy= is_buy;
   g_retired[n].t1    = t1n;
   g_retired[n].top   = hi;
   g_retired[n].bot   = lo;
}


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void RememberZone(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot, bool retired)
  {
   int ti=TFSlot(tf), si=SideSlot(is_buy);
   g_htf[ti][si].inited=true;
   g_htf[ti][si].retired=retired;
   g_htf[ti][si].t1=t1;
   g_htf[ti][si].top=top;
   g_htf[ti][si].bot=bot;


   if(retired)
      MarkRetired(tf,is_buy,t1,top,bot);
//Clear out any validation for this zone if it gets retired
   if(retired)
      UnmarkZoneValidated(tf,is_buy,t1,top,bot);

  }



// ====== CONFIRMATION ENGINE HELPERS ====== //
// --- map token text -> index
int ConfirmTokenIndex(const string &tok_in)
  {
   string tok = Upper(Trim(tok_in));
   if(tok=="MFVG")
      return 0;
   if(tok=="BOS")
      return 1;
   if(tok=="RETEST")
      return 2;
   if(tok=="ENGULF")
      return 3;
   if(tok=="SFP")
      return 4;
   if(tok=="IB")
      return 5;
   if(tok=="WICK")
      return 6;
   return -1;
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int SplitCSV(const string &s, const string &sep, string &out[])
  {
   ArrayResize(out,0);
   if(StringLen(s)==0)
      return 0;
   ushort d = (ushort)StringGetCharacter(sep,0);
   return StringSplit(s, d, out);
  }


// --- child TF for BOS (default + user overrides for M5/M15)
// ENUM_TIMEFRAMES ChildTFForBOS(ENUM_TIMEFRAMES ltf)
//   {
//    if(ltf==PERIOD_M5)
//       return Inp_BOS_Child_M5;
//    if(ltf==PERIOD_M15)
//      {
//       if(Inp_HTFMode==HTF_M15_M1)
//          return PERIOD_M1; // scalper mapping
//       return Inp_BOS_Child_M15;
//      }
// // scalper mapping: when confirmations run on M1, check BOS on M1 as well
//    if(ltf==PERIOD_M1)
//       return PERIOD_M1;
//    switch(ltf)
//      {
//       case PERIOD_H1:
//          return PERIOD_M3;
//       case PERIOD_H4:
//          return PERIOD_M5;


//       default:
//          return PERIOD_M3;
//      }
//   }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+

//===1H FVG/5M conf -> 3M BOS, 4H FVG/15M conf -> 5M BOS===///
// ENUM_TIMEFRAMES ChildTFForBOS(ENUM_TIMEFRAMES ltf)
//   {
//    ENUM_TIMEFRAMES c=(ltf==PERIOD_M5?Inp_BOS_Child_M5:(ltf==PERIOD_M15?Inp_BOS_Child_M15:(ltf==PERIOD_H1?PERIOD_M3:(ltf==PERIOD_H4?PERIOD_M5:PERIOD_M1))));
//    if(iBars(_Symbol,c)<=0)
//       c=(c==PERIOD_M3?PERIOD_M1:c);
//    if(iBars(_Symbol,c)<=0)
//       c=PERIOD_M1;
//    return c;
//   }

//=== 1H FVG/5M conf -> 1M BOS, 4H FVG/15M conf -> 3M BOS ===///
ENUM_TIMEFRAMES ChildTFForBOS(ENUM_TIMEFRAMES ltf)
  {
   // Use user-selected child BOS timeframes for each HTF
   ENUM_TIMEFRAMES c = PERIOD_M1; // default fallback
   if(ltf == PERIOD_M5)
      c = Inp_BOS_Child_M5;
   else if(ltf == PERIOD_M15)
      c = Inp_BOS_Child_M15;
   else if(ltf == PERIOD_H1)
      c = Inp_BOS_Child_H1;
   else if(ltf == PERIOD_H4)
      c = Inp_BOS_Child_H4;
   // else fallback to 1M
   if(iBars(_Symbol,c)<=0)
      c=(c==PERIOD_M3?PERIOD_M1:c);
   if(iBars(_Symbol,c)<=0)
      c=PERIOD_M1;
   return c;
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int SplitByPlus(const string &s, string &out[])
  {
   return StringSplit(s, '+', out);
  }

/// @brief /// Find the last swing (high for sell leg, low for buy leg) in the leg
/// @param is_buy
/// @param s
/// @param k
/// @param swing
/// @return
bool FindLastLegSwing(bool is_buy, int s, int k, double &swing)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+120, r, bars) || bars < s+5)
      return false;

// scan backwards from s+1 (older bars) to find the nearest swing in the leg
   for(int i=s+1; i<MathMin(bars-1, s+80); ++i)
     {
      if(is_buy && IsSwingLow(r,i,k))
        {
         swing = r[i].low;
         return true;
        }
      if(!is_buy && IsSwingHigh(r,i,k))
        {
         swing = r[i].high;
         return true;
        }
     }
// fallback: use bar s+1 extreme
   swing = is_buy ? r[s+1].low : r[s+1].high;
   return true;
  }


/// ===================MICRO CONFIRMATIONS ON LTF CONFIRMATIONS FOR PENDING ORDERS=================== ///
bool GetMicroFVGEdgesAt(bool is_buy, int s, double &edgeNear, double &edgeFar)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+4, r, bars) || bars < s+3)
      return false;

   if(is_buy)
     {
      // bullish gap: right.low > left2.high
      if(r[s].low > r[s+2].high)
        {
         double lower = r[s+2].high, upper = r[s].low;
         edgeNear = upper;
         edgeFar = lower;   // “start of gap” (first touched on retrace) = upper
         return true;
        }
     }
   else
     {
      if(r[s].high < r[s+2].low)
        {
         double lower = r[s].high, upper = r[s+2].low;
         edgeNear = lower;
         edgeFar = upper;   // “start of gap” for sells = lower
         return true;
        }
     }
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool GetBOSLevelAt(bool is_buy, int s, int k, double &lvl)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+60, r, bars) || bars < s+5)
      return false;
   for(int i=s+1; i<MathMin(bars-1, s+40); ++i)
     {
      if(is_buy && IsSwingHigh(r,i,k))
        {
         lvl = r[i].high;   // broken high
         return true;
        }
      if(!is_buy && IsSwingLow(r,i,k))
        {
         lvl = r[i].low;    // broken low
         return true;
        }
     }
   return false;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool GetSFPRefAt(bool is_buy, int s, double &lvl)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+6, r, bars) || bars < s+4)
      return false;
   if(is_buy)
     {
      lvl = MathMin(r[s+1].low, MathMin(r[s+2].low, r[s+3].low)); // prior swing low swept
     }
   else
     {
      lvl = MathMax(r[s+1].high, MathMax(r[s+2].high, r[s+3].high)); // prior swing high swept
     }
   return true;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool GetIBBoundaryAt(bool is_buy, int s, double &lvl)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+4, r, bars) || bars < s+3)
      return false;
   double hi2=r[s+2].high, lo2=r[s+2].low;    // mother
   double hi1=r[s+1].high, lo1=r[s+1].low;    // inside?
   if(!(hi1<=hi2 && lo1>=lo2))
      return false;
   lvl = is_buy ? hi1 : lo1;
   return true;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ComputePendingAnchor(const Candidate &C, int s, const string &confirmTag,
                          double &entryAnchor, string &anchorName)
  {
   string toks[];
   int nt = SplitByPlus(confirmTag, toks);

// priority (first matching wins). You can reorder if you like.
   string prio[] = {"MFVG","BOS","RETEST","ENGULF","SFP", "IB"};

   for(int p=0; p<ArraySize(prio); ++p)
     {
      for(int i=0; i<nt; ++i)
        {
         string t = Upper(Trim(toks[i]));
         if(t != prio[p])
            continue;

         double lvl;
         if(t=="MFVG")
           {
            double near_, far_;
            if(GetMicroFVGEdgesAt(C.is_buy, s, near_, far_))
              {
               entryAnchor = near_;
               anchorName="MFVG(start)";
               return true;
              }
           }
         if(t=="ENGULF")
           {
            MqlRates r[];
            int bars;
            if(CopyRatesTF(TF_LTF(), s+2, r, bars) && bars >= s+1)
              {
               entryAnchor = r[s].close;
               anchorName="ENGULF(close)";
               return true;
              }
           }
         if(t=="BOS")
           {
            if(GetBOSLevelAt(C.is_buy, s, Inp_SW_Pivot, lvl))
              {
               entryAnchor = lvl;
               anchorName="BOS(level)";
               return true;
              }
           }
         if(t=="SFP")
           {
            if(GetSFPRefAt(C.is_buy, s, lvl))
              {
               entryAnchor = lvl;
               anchorName="SFP(swept)";
               return true;
              }
           }
         if(t=="RETEST")
           {
            entryAnchor = FvgThreshold(C.top, C.bot, C.is_buy);
            anchorName  = "RETEST(threshold)";
            return true;
           }
         if(t=="IB")
           {
            if(GetIBBoundaryAt(C.is_buy, s, lvl))
              {
               entryAnchor = lvl;
               anchorName="IB(boundary)";
               return true;
              }
           }
        }
     }
   return false; // fall back handled by caller
  }


//==================== FVG THRESHOLDS ====================//
double FvgThreshold(double top, double bot, bool is_buy)
  {
   if(Inp_MitigationMode==MitigateAt50)
      return (top+bot)*0.5;
   if(Inp_MitigationMode==MitigateOnTouch)
      return is_buy ? top : bot;
   return is_buy ? bot : top;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsMitigated_HTF(double top, double bot, bool is_buy, ENUM_TIMEFRAMES htf)
  {
   double th  = FvgThreshold(top, bot, is_buy);

   double lastLTF = iClose(_Symbol, _Period, 1);
   bool ltfCross  = is_buy ? (lastLTF <= th) : (lastLTF >= th);

   double lastHTF = iClose(_Symbol, htf, 1);
   bool htfCross  = is_buy ? (lastHTF <= th) : (lastHTF >= th);

   double last = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   bool tickCross = is_buy ? (last <= th) : (last >= th);

   return (ltfCross || htfCross || tickCross);
  }

// bool IsMitigated_HTF(double top, double bot, bool is_buy, ENUM_TIMEFRAMES htf)
// {
//    // Dynamic level (center/33%/full etc.) driven by Inp_MitigationMode inside FvgThreshold()
//    const double th = FvgThreshold(top, bot, is_buy);

//    // Use the correct child LTF for mitigation checks (not the chart TF)
//    ENUM_TIMEFRAMES ltf =
//       (htf==PERIOD_H1  ? PERIOD_M5  :
//       (htf==PERIOD_H4  ? PERIOD_M15 :
//       (htf==PERIOD_M15 ? PERIOD_M1  : (ENUM_TIMEFRAMES)_Period)));

//    // // --- wick/tick touch (fast) ---  Comment to have close-only checks not wick/tick
//    // const double lLow  = iLow(_Symbol,  ltf, 1);
//    // const double lHigh = iHigh(_Symbol, ltf, 1);
//    // const bool wickTouch = (is_buy ? (lLow  <= th) : (lHigh >= th));

//    const double lastB = SymbolInfoDouble(_Symbol, SYMBOL_BID);
//    const double lastA = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
//    const double lastL = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
//    const bool tickTouch = (is_buy ? (lastB <= th || lastA <= th || lastL <= th)
//                                   : (lastB >= th || lastA >= th || lastL >= th));

//    // --- close-based checks (LTF and HTF closes) ---
//    const double cLTF = iClose(_Symbol, ltf, 1);
//    const double cHTF = iClose(_Symbol, htf, 1);
//    const bool ltfClose = (is_buy ? (cLTF <= th) : (cLTF >= th));
//    const bool htfClose = (is_buy ? (cHTF <= th) : (cHTF >= th));

//    // Combine (dynamic threshold already handled by FvgThreshold)
//    // If you want *close-only*, return (ltfClose || htfClose).
//    // return (wickTouch || tickTouch || ltfClose || htfClose);
//    return (ltfClose || htfClose);

// }



//==================== OLD-TF SCAN (generic zone painter) =======//
void ScanTF(ENUM_TIMEFRAMES tf)
  {
   MqlRates r[];
   int bars = CopyRates(_Symbol, tf, 0, MathMax(Inp_LookbackBars,300), r);
   if(bars<20)
      return;
   ArraySetAsSeries(r,true);

   datetime last_right = g_last_right_time[TFIndex(tf)];
   for(int s=bars-3; s>=2; --s)
     {
      datetime t_right = r[s].time;
      if(last_right!=0 && t_right<=last_right)
         break;

      double low_r  = r[s].low;
      double high_r = r[s].high;
      double low_l  = r[s+2].low;
      double high_l = r[s+2].high;

      if(low_r > high_l) // bullish
        {
         double lower = high_l, upper = low_r;
         if(PassesSizeFilter(tf, lower, upper))
           {
            FVGZone z;
            z.tf=tf;
            z.bullish=true;
            z.lower=lower;
            z.upper=upper;
            z.t_left = r[s+2].time;
            z.t_right = t_right;
            z.id=0;
            z.name="";
            z.name50="";
            TryMergeNewIntoExisting(z);
           }
        }
      if(high_r < low_l) // bearish
        {
         double lower = high_r, upper = low_l;
         if(PassesSizeFilter(tf, lower, upper))
           {
            FVGZone z;
            z.tf=tf;
            z.bullish=false;
            z.lower=lower;
            z.upper=upper;
            z.t_left = r[s+2].time;
            z.t_right = t_right;
            z.id=0;
            z.name="";
            z.name50="";
            TryMergeNewIntoExisting(z);
           }
        }
     }
   g_last_right_time[TFIndex(tf)] = r[1].time;
  }

//==================== STRUCTURE & CONTEXT ====================//

// ---- SAFE array copy helper (arrays passed by ref) ----
bool CopyRatesTF(ENUM_TIMEFRAMES tf, int need, MqlRates &r[], int &bars)
  {
   bars = CopyRates(_Symbol, tf, 0, need, r);
   if(bars<=0)
      return false;
   ArraySetAsSeries(r, true);
   return true;
  }



// ---- SAFE array copy helper stays the same ----
// bool CopyRatesTF(...);

// === REPLACE WITH THESE BOUND-SAFE VERSIONS ===
bool IsSwingHigh(const MqlRates &r[], int i, int k)
  {
   int bars = ArraySize(r);
   if(bars==0)
      return false;
// need i-k >= 0 and i+k <= bars-1
   if(i < k || i+k >= bars)
      return false;
   for(int j=1; j<=k; ++j)
     {
      if(!(r[i].high > r[i-j].high && r[i].high >= r[i+j].high))
         return false;
     }
   return true;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsSwingLow(const MqlRates &r[], int i, int k)
  {
   int bars = ArraySize(r);
   if(bars==0)
      return false;
   if(i < k || i+k >= bars)
      return false;
   for(int j=1; j<=k; ++j)
     {
      if(!(r[i].low < r[i-j].low && r[i].low <= r[i+j].low))
         return false;
     }
   return true;
  }

// === REPLACE HTF_BiasAndRange WITH THIS VERSION ===
int HTF_BiasAndRange(ENUM_TIMEFRAMES tf, int k, double &legLow, double &legHigh)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(tf, 600, r, bars) || bars < (2*k+5))
     {
      legLow=0;
      legHigh=0;
      return 0;
     }

// seed refs safely inside bounds
   int i_start = bars-1-k;   // highest i where i+k <= bars-1
   int i_end   = k;          // lowest i where i-k >= 0
   if(i_start < i_end)
     {
      legLow=0;
      legHigh=0;
      return 0;
     }

   double refHigh = r[i_start].high;
   double refLow  = r[i_start].low;

   int lastDir=0, prevDir=0;

// scan older -> newer in terms of index decrease (series=true)
   for(int i=i_start; i>=i_end; --i)
     {
      if(IsSwingHigh(r,i,k))
         refHigh = r[i].high;
      if(IsSwingLow(r,i,k))
         refLow  = r[i].low;

      // break by close (use i-1 which is more recent than i; ensure i-1 >= 0)
      if(i-1 >= 0)
        {
         if(r[i-1].close > refHigh)
           {
            prevDir=lastDir;
            lastDir=+1;
           }
         if(r[i-1].close < refLow)
           {
            prevDir=lastDir;
            lastDir=-1;
           }
        }
     }

// leg range over a recent safe window [1 .. win]
   int win = MathMin(200, bars-2);
   double hi = r[1].high, lo = r[1].low;
   for(int i=1; i<=win; ++i)
     {
      if(r[i].high > hi)
         hi = r[i].high;
      if(r[i].low  < lo)
         lo = r[i].low;
     }
   legLow = lo;
   legHigh = hi;

   if(lastDir!=0 && prevDir==lastDir)
      return lastDir;
   if(lastDir!=0 && prevDir==0)
      return lastDir;
   return 0;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool InProperLocation(bool is_buy, double price, double legLow, double legHigh)
  {
   if(legHigh<=legLow)
      return true;
   double mid = (legHigh+legLow)*0.5;
   if(is_buy)
      return price <= mid;
   else
      return price >= mid;
  }

 // Helper: ATR at specific bar shift on a TF (returns 0 on failure)
double ATR_At(ENUM_TIMEFRAMES tf, int period, int shift) {
   int h = iATR(_Symbol, tf, period);
   if(h == INVALID_HANDLE) return 0.0;
   double buf[];
   // Copy exactly 1 value starting at 'shift'
   if(CopyBuffer(h, 0, shift, 1, buf) != 1) {
      IndicatorRelease(h);
      return 0.0;
   }
   IndicatorRelease(h);
   return buf[0];
}

// Displacement anchored to the FVG bar (t1 = LEFT bar time)
bool HTF_DisplacementFactor(ENUM_TIMEFRAMES tf, datetime t1, double &disp) {
   disp = 0.0;

   int left  = iBarShift(_Symbol, tf, t1, true);
   if(left <= 0) return false;
   int mid   = left - 1;
   int right = left - 2;
   if(right < 0) return false;

   // impulse of middle bar body vs structural gap
   double oMid = iOpen(_Symbol, tf, mid);
   double cMid = iClose(_Symbol, tf, mid);
   double body = MathAbs(cMid - oMid);

   double hLeft  = iHigh(_Symbol, tf, left);
   double lLeft  = iLow(_Symbol, tf, left);
   double hRight = iHigh(_Symbol, tf, right);
   double lRight = iLow(_Symbol, tf, right);

   double gapBuy  = MathMax(0.0, lRight - hLeft);
   double gapSell = MathMax(0.0, lLeft  - hRight);
   double gap     = MathMax(gapBuy, gapSell);

   double impulse = MathMax(body, gap);

   // *** Anchor ATR to the FVG bar (mid preferred) ***
   double atr = ATR_At(tf, Inp_ATR_Period, mid);
   if(atr <= 0.0) atr = ATR_At(tf, Inp_ATR_Period, left);
   if(atr <= 0.0) atr = ATR_At(tf, Inp_ATR_Period, right);
   if(atr <= 0.0) return false;

   disp = impulse / atr;
   return (disp > 0.0);
}

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool HTF_SweepHeuristic(ENUM_TIMEFRAMES tf, datetime t1, bool is_buy)
  {
   int bars;
   MqlRates r[];
   if(!CopyRatesTF(tf, 120, r, bars))
      return false;
   int idxLeft = iBarShift(_Symbol, tf, t1, true);
   int s = idxLeft-1;
   int look = MathMin(20, bars-5);
   if(s<0)
      s=0;
   if(is_buy)
     {
      double priorLow = r[s+3].low;
      for(int i=s+3;i<=s+3+look && i<bars; i++)
        {
         if(r[i].low<priorLow)
            priorLow=r[i].low;
        }
      double seqLow = MathMin(r[s].low, MathMin(r[s+1].low, r[s+2].low));
      return (seqLow <= priorLow);
     }
   else
     {
      double priorHigh = r[s+3].high;
      for(int i=s+3;i<=s+3+look && i<bars; i++)
        {
         if(r[i].high>priorHigh)
            priorHigh=r[i].high;
        }
      double seqHigh = MathMax(r[s].high, MathMax(r[s+1].high, r[s+2].high));
      return (seqHigh >= priorHigh);
     }
  }

//==================== LTF CONFIRMATIONS (with backfill) ========//

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_Engulf(bool is_buy)
  {
   return LTF_EngulfAt(is_buy, 1);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_WickRejection(bool is_buy)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), 5, r, bars) || bars<2)
      return false;

   double hi=r[1].high, lo=r[1].low, op=r[1].open, cl=r[1].close;
   double range = hi-lo;
   if(range<=0)
      return false;

   double lowerWick = MathMax(0.0, MathMin(op,cl)-lo);
   double upperWick = MathMax(0.0, hi - MathMax(op,cl));

   return is_buy ? (lowerWick >= 0.60*range && cl>op)
          : (upperWick >= 0.60*range && cl<op);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_MicroFVG(bool is_buy)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), 6, r, bars) || bars<5)
      return false;

   int s=1; // last closed is right candle
   return is_buy ? (r[s].low  > r[s+2].high)
          : (r[s].high < r[s+2].low);
  }


// Legacy signature, now routes to the full engine (ENGULF, MFVG, WICK, BOS, SFP, RETEST, IB)
bool LTF_Confirmation(bool is_buy, string &which)
  {
   which = "";

   int best = -1;
   double bestDist = DBL_MAX;
   Candidate C;
   C.valid = false;

   for(int i=0; i<g_zone_count; ++i)
     {
      // use direct indexing (no '&' references)
      if(!g_zones[i].active || g_zones[i].bullish != is_buy)
         continue;
      if(!LTF_TouchedZoneAt(g_zones[i].upper, g_zones[i].lower, 1))
         continue;

      Candidate tmp;
      double top = g_zones[i].upper;
      double bot = g_zones[i].lower;
      double mid = 0.5*(top+bot);

      if(!BuildCandidateFromZone(is_buy, g_zones[i].tf, g_zones[i].t_left, top, bot, mid, tmp))
         continue;

      double d = MathAbs(SymbolInfoDouble(_Symbol, SYMBOL_BID) - mid);
      if(d < bestDist)
        {
         bestDist = d;
         best = i;
         C = tmp;
        }
     }

   if(best < 0)
      return false;

// s=1 -> last closed LTF bar; this calls your K-of-N / Pairs logic with BOS, SFP, RETEST, IB, etc.
   return LTF_ConfirmationAt2(C, 1, which);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_TouchedZoneAt(double top,double bot,int shift)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), 10+shift, r, bars) || bars<=shift+1)
      return false;
   double hi=r[shift].high, lo=r[shift].low;
   return !(hi < bot || lo > top);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_ClosedInsideZoneAt(double top,double bot,int shift)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), 1+shift, r, bars) || bars<=shift)
      return false;
   double cl=r[shift].close;
   double zHi=MathMax(top,bot), zLo=MathMin(top,bot);
   return (cl>=zLo && cl<=zHi);
  }

 
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_BOSAt(bool is_buy,int s)
  {
   datetime t_open=iTime(_Symbol,TF_LTF(),s), t_close=iTime(_Symbol,TF_LTF(),s-1);
   if(!t_open || !t_close)
      return false;
   ENUM_TIMEFRAMES ctf=ChildTFForBOS(TF_LTF());
   MqlRates cr[];
   int cb=CopyRates(_Symbol,ctf,0,800,cr);
   if(cb<=60)
     {
      ctf=PERIOD_M1;
      cb=CopyRates(_Symbol,ctf,0,800,cr);
     }
   if(cb<=60)
     {
      MqlRates lr[];
      int lb;
      if(!CopyRatesTF(TF_LTF(),s+40,lr,lb)||lb<s+5)
         return false;
      ArraySetAsSeries(lr,true);
      double hi=-DBL_MAX,lo=DBL_MAX;
      for(int i=s+1;i<=s+30 && i<lb;i++)
        {
         if(lr[i].high>hi)
            hi=lr[i].high;
         if(lr[i].low<lo)
            lo=lr[i].low;
        }
      double cl=lr[s].close;
      return is_buy ? (cl>hi) : (cl<lo);
     }
   ArraySetAsSeries(cr,true);
   int iS=iBarShift(_Symbol,ctf,t_open,true), iE=iBarShift(_Symbol,ctf,t_close,true);
   if(iS<0||iE<0||iS<iE)
      return false;
   double pHi=-DBL_MAX,pLo=DBL_MAX;
   for(int i=iS+1;i<=iS+30 && i<cb;i++)
     {
      if(cr[i].high>pHi)
         pHi=cr[i].high;
      if(cr[i].low<pLo)
         pLo=cr[i].low;
     }
   for(int i=iE;i<=iS && i<cb;i++)
     {
      double cl=cr[i].close;
      if(is_buy && cl>pHi)
         return true;
      if(!is_buy && cl<pLo)
         return true;
     }
   return false;
  }


// ==== SFP (liquidity grab) on LTF bar s ====
bool LTF_SFPAt(bool is_buy, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+6, r, bars) || bars < s+4)
      return false;

// prior swing (k=2) from the 3 bars before s
   double ref;
   if(is_buy)
     {
      // prior swing low
      ref = MathMin(r[s+1].low, MathMin(r[s+2].low, r[s+3].low));
      // current bar must pierce below ref but close back above
      double hi=r[s].high, lo=r[s].low, op=r[s].open, cl=r[s].close;
      double range = hi-lo;
      if(range<=0)
         return false;
      double lowerWick = MathMax(0.0, MathMin(op,cl)-lo);
      return (lo < ref && cl > ref && lowerWick >= 0.5*range);
     }
   else
     {
      // prior swing high
      ref = MathMax(r[s+1].high, MathMax(r[s+2].high, r[s+3].high));
      double hi=r[s].high, lo=r[s].low, op=r[s].open, cl=r[s].close;
      double range = hi-lo;
      if(range<=0)
         return false;
      double upperWick = MathMax(0.0, hi - MathMax(op,cl));
      return (hi > ref && cl < ref && upperWick >= 0.5*range);
     }
  }

// ==== Retest of FVG threshold (touch-back-go) on LTF bar s ====
bool LTF_RetestThresholdAt(bool is_buy, int s, double top, double bot, ENUM_TIMEFRAMES htf)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+2, r, bars) || bars < s+1)
      return false;

   double th = FvgThreshold(top, bot, is_buy);
   double hi = r[s].high, lo = r[s].low;
   double op = r[s].open, cl = r[s].close;
   double eps = MathMax(_Point*2.0, 1e-6);

   bool touched = (lo <= th + eps && hi >= th - eps);
   if(!touched)
      return false;

// close away from threshold, in the intended direction (allow near-dojis)
   if(is_buy)
     {
      if(cl <= th + eps)
         return false;
      if(cl + eps < op)
         return false;
      return true;
     }
   else
     {
      if(cl >= th - eps)
         return false;
      if(cl - eps > op)
         return false;
      return true;
     }
  }

// ==== Inside-Bar break (IB -> breakout) using LTF bars s, s+1, s+2 ====
bool LTF_InsideBarBreakAt(bool is_buy, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+4, r, bars) || bars < s+3)
      return false;

   double hi2=r[s+2].high, lo2=r[s+2].low;   // mother bar
   double hi1=r[s+1].high, lo1=r[s+1].low;   // inside bar?
   bool inside = (hi1 <= hi2 && lo1 >= lo2);
   if(!inside)
      return false;

   double cl=r[s].close;
   if(is_buy)
      return (cl > hi1);  // break upward
   else
      return (cl < lo1);  // break downward
  }


// Build all raw signals for bar s
void BuildAllConfsAt(const Candidate &C, int s, bool &flags[])
  {
// ensure size >= 7
   if(ArraySize(flags)<7)
      ArrayResize(flags,7);
   flags[0] = LTF_EngulfAt(C.is_buy, s);
   flags[1] = LTF_MicroFVGAt(C.is_buy, s);
   flags[2] = LTF_WickRejectionAt(C.is_buy, s);
   flags[3] = LTF_BOSAt(C.is_buy, s);
   flags[4] = LTF_SFPAt(C.is_buy, s);
   flags[5] = LTF_RetestThresholdAt(C.is_buy, s, C.top, C.bot, C.htf);
   flags[6] = LTF_InsideBarBreakAt(C.is_buy, s);
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool EvaluatePairs_UI(const bool &flags[], string &which)
  {

   if(DailyLossHit())
     {
      DebugPanel("Trading paused: daily loss limit hit.");
      return false;
     }

   struct PairDef { bool en; EConfirmation a; EConfirmation b; };
   PairDef P[6] =
     {
        { Inp_ConfirmPair1_Enable, Inp_ConfirmPair1_A, Inp_ConfirmPair1_B },
        { Inp_ConfirmPair2_Enable, Inp_ConfirmPair2_A, Inp_ConfirmPair2_B },
        { Inp_ConfirmPair3_Enable, Inp_ConfirmPair3_A, Inp_ConfirmPair3_B },
        { Inp_ConfirmPair4_Enable, Inp_ConfirmPair4_A, Inp_ConfirmPair4_B },
        { Inp_ConfirmPair5_Enable, Inp_ConfirmPair5_A, Inp_ConfirmPair5_B },
        { Inp_ConfirmPair6_Enable, Inp_ConfirmPair6_A, Inp_ConfirmPair6_B }
     };

   for(int i=0;i<6;i++)
     {
      if(!P[i].en)
         continue;
      int a = ConfirmEnumToIndex(P[i].a);
      int b = ConfirmEnumToIndex(P[i].b);
      if(a<0 || b<0)
         continue;
      if(a<ArraySize(flags) && b<ArraySize(flags) && flags[a] && flags[b])
        {
         which = ConfirmIndexToName(a) + "+" + ConfirmIndexToName(b);
         return true;
        }
     }
   return false;
  }



// New master confirmation: uses custom list if provided, else legacy behavior
bool LTF_ConfirmationAt2(const Candidate &C, int s, string &which)
  {
   which = "";

// Build all raw confirmations for bar s
   bool flags[];
   ArrayResize(flags,7);
   BuildAllConfsAt(C, s, flags);

// Post-touch gating: if g_ftShiftActive>=1, disallow patterns that would
// reference bars older than the first-touch bar. With series indexing,
// older bars are at larger shifts (s+N). Guard each flag accordingly.
   if(g_ftShiftActive>=1)
     {
      if(s+1 > g_ftShiftActive)
         flags[0]=false; // ENGULF needs s+1
      if(s+2 > g_ftShiftActive)
         flags[1]=false; // MFVG needs s+2
      if(s     > g_ftShiftActive)
         flags[2]=false; // WICK on s
      if(s     > g_ftShiftActive)
         flags[3]=false; // BOS on s window
      // SFP deliberately allowed to reference pre-touch swings
      if(s     > g_ftShiftActive)
         flags[5]=false; // RETEST on s
      if(s+2 > g_ftShiftActive)
         flags[6]=false; // IB needs s+2
     }

// ---- Preferred: structured UI path ----
   if(Inp_UI_UseStructured)
     {
      if(Inp_UI_UsePairs)
        {
         return EvaluatePairs_UI(flags, which);
        }
      else
        {
         // K-of-N using confirmation checkboxes
         bool chosen[7] =
           {
            Inp_UI_Confirm_ENGULF, Inp_UI_Confirm_MFVG, Inp_UI_Confirm_WICK,
            Inp_UI_Confirm_BOS,    Inp_UI_Confirm_SFP,  Inp_UI_Confirm_RETEST,
            Inp_UI_Confirm_IB
           };
         int need = MathMax(1, Inp_UI_Confirm_K);
         int have = 0;
         string lab="";
         for(int k=0;k<7;k++)
           {
            if(!chosen[k])
               continue;
            if(flags[k])
              {
               have++;
               if(StringLen(lab)>0)
                  lab+="+";
               lab += ConfirmIndexToName(k);
              }
           }
         if(have >= need)
           {
            which = (StringLen(lab)>0? lab : "CUSTOM");
            return true;
           }
         return false;
        }
     }

// ---- Fallback: legacy Strict/Standard/Aggressive (unchanged) ----
   bool engulf=LTF_EngulfAt(C.is_buy,s);
   bool mfvg =LTF_MicroFVGAt(C.is_buy,s);
   bool wick =LTF_WickRejectionAt(C.is_buy,s);

   if(Inp_ConfirmMode==Confirm_Strict)
     {
      if(engulf && mfvg)
        {
         which="ENGULF+MFVG";
         return true;
        }
      return false;
     }
   else
      if(Inp_ConfirmMode==Confirm_Standard)
        {
         if(engulf || mfvg)
           {
            which = (engulf? "ENGULF" : "MFVG");
            return true;
           }
         return false;
        }
      else   // Confirm_Aggressive
        {
         if(engulf||mfvg||wick)
           {
            which = engulf? "ENGULF" : (mfvg? "MFVG":"WICK");
            return true;
           }
         return false;
        }
  }


//==================== SIGNAL DRAWING ====================//
void DrawSLTP(const string &base, double entry, double sl, double tp1, double tp2, color clr)
  {
   if(!Inp_DrawSLTP)
      return;
   string l1=base+"_SL", l2=base+"_TP1", l3=base+"_TP2";
   datetime now = TimeCurrent();
   int tfsec = PeriodSeconds(PERIOD_CURRENT);
   datetime far = now + 12*tfsec;

// SL
   if(ObjectFind(0,l1)<0)
      ObjectCreate(0,l1,OBJ_TREND,0,now,sl,far,sl);
   ObjectSetInteger(0,l1,OBJPROP_COLOR, clrRed);
   ObjectSetInteger(0,l1,OBJPROP_STYLE, STYLE_DASHDOT);
   ObjectSetInteger(0,l1,OBJPROP_BACK, false);

// TP1 (only if > 0)
   if(tp1>0.0)
     {
      if(ObjectFind(0,l2)<0)
         ObjectCreate(0,l2,OBJ_TREND,0,now,tp1,far,tp1);
      ObjectSetInteger(0,l2,OBJPROP_COLOR, clr);
      ObjectSetInteger(0,l2,OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0,l2,OBJPROP_BACK, false);
     }
   else
      if(ObjectFind(0,l2)>=0)
        {
         ObjectDelete(0,l2);
        }

// TP2 (only if > 0)
   if(tp2>0.0)
     {
      if(ObjectFind(0,l3)<0)
         ObjectCreate(0,l3,OBJ_TREND,0,now,tp2,far,tp2);
      ObjectSetInteger(0,l3,OBJPROP_COLOR, clr);
      ObjectSetInteger(0,l3,OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0,l3,OBJPROP_BACK, false);
     }
   else
      if(ObjectFind(0,l3)>=0)
        {
         ObjectDelete(0,l3);
        }

   ChartRedraw();
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string MakeSigIdAt(const Candidate &c, int ltfShift)
  {
   datetime tbar = iTime(_Symbol, TF_LTF(), ltfShift);
   return StringFormat("ZERO_SIG_%s_%s_%I64d_%I64d",
                       (c.is_buy?"BUY":"SELL"), TFToStr(c.htf), (long)c.t1, (long)tbar);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void RemoveSignalGraphicsById(const string &id)
  {
// remove any object that belongs to this signal (all wrapped lines start with id+"_LBL")
   int total = ObjectsTotal(0,-1,-1);
   for(int i=total-1;i>=0;--i)
     {
      string nm = ObjectName(0,i);
      if(nm==id+"_ARR" || nm==id+"_SL" || nm==id+"_TP1" || nm==id+"_TP2" ||
         StringFind(nm, id+"_LBL")==0 || StringFind(nm, id+"_DBG")==0)
        {
         ObjectDelete(0,nm);
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CountDrawnSameBarSide(datetime when, bool is_buy)
  {
   int c=0;
   for(int i=0;i<ArraySize(g_signals);++i)
      if(g_signals[i].drawn && g_signals[i].when==when && g_signals[i].is_buy==is_buy)
         c++;
   return c;
  }

// Keep chart clean:
//  - hide visuals older than Inp_SignalKeepBars bars
//  - keep only newest per (HTF zone + side)
//  - cap global visible signals to Inp_MaxSignalsOnChart
void TidySignalVisuals()
  {
   int n = ArraySize(g_signals);
   if(n<=0)
      return;

// create index list and sort it by recency (newest first)
   int idx[];
   ArrayResize(idx, n);
   for(int i=0;i<n;i++)
      idx[i]=i;

   for(int i=0;i<n;i++)
     {
      int best=i;
      for(int j=i+1;j<n;j++)
         if(g_signals[idx[j]].when > g_signals[idx[best]].when)
            best=j;
      if(best!=i)
        {
         int t=idx[i];
         idx[i]=idx[best];
         idx[best]=t;
        }
     }

// walk newest -> oldest; keep only newest per HTF zone and cap total
   string kept_keys[];
   ArrayResize(kept_keys,0);
   int kept=0;

   for(int p=0; p<n; ++p)
     {
      int i = idx[p];

      // hide anything older than N LTF bars
      int shift = iBarShift(_Symbol, TF_LTF(), g_signals[i].when, true);
      if(shift==-1 || shift > Inp_SignalKeepBars)
        {
         RemoveSignalGraphicsById(g_signals[i].id);
         g_signals[i].drawn=false;
         continue;
        }

      // per-zone key: (tf|side|t1|top|bot)
      string key = StringFormat("%s|%c|%I64d|%.8f|%.8f",
                                TFToStr(g_signals[i].htf),
                                (g_signals[i].is_buy?'B':'S'),
                                (long)g_signals[i].z_t1,
                                g_signals[i].z_top,
                                g_signals[i].z_bot);

      bool already=false;
      for(int k=0;k<ArraySize(kept_keys);++k)
        {
         if(kept_keys[k]==key)
           {
            already=true;
            break;
           }
        }

      if(already || kept>=Inp_MaxSignalsOnChart)
        {
         // hide older duplicates / overflow
         RemoveSignalGraphicsById(g_signals[i].id);
         g_signals[i].drawn=false;
         continue;
        }

      // keep this one visible
      int m=ArraySize(kept_keys);
      ArrayResize(kept_keys,m+1);
      kept_keys[m]=key;
      kept++;
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void DrawSignalLabel(const Signal &s, color clr)
  {
// if(!isVisual) return;

   if(!Inp_ShowLabels && !Inp_ShowArrows)
      return;

// stacking if several signals share same bar+side
   const int    rank = CountDrawnSameBarSide(s.when, s.is_buy);
   const double baseStep = Inp_LabelYStepPoints * _Point;
   const double lineStep = Inp_LabelLineStepPoints * _Point;

   const double yBase = s.is_buy ? (s.entry + (rank+1.00)*baseStep)
                        : (s.entry - (rank+1.00)*baseStep);
   const datetime t   = s.when;

// ---------- build lines ----------
   string tpTxt="";
   if(s.tp1>0.0 && s.tp2>0.0)
      tpTxt = StringFormat("TP1 %.*f | TP2 %.*f", DigitsSym(), s.tp1, DigitsSym(), s.tp2);
   else
      if(s.tp1>0.0)
         tpTxt = StringFormat("TP1 %.*f", DigitsSym(), s.tp1);
      else
         if(s.tp2>0.0)
            tpTxt = StringFormat("TP2 %.*f", DigitsSym(), s.tp2);
         else
            tpTxt = "TP —";

   string header = StringFormat("%s %s  @%.*f | SL %.*f | %s | %s",
                                (s.is_buy?"BUY":"SELL"), TFToStr(s.htf),
                                DigitsSym(), s.entry, DigitsSym(), s.sl, tpTxt, s.confirm);

   string lines[];
   ArrayResize(lines,1);
   lines[0]=header;
   if(Inp_LabelDetail!=Label_Off && StringLen(s.info)>0)
     {
      string wrapped[];
      WrapLines(s.info, Inp_LabelWrapChars, wrapped);
      int m=ArraySize(wrapped);
      if(m>0)
        {
         int n=ArraySize(lines);
         ArrayResize(lines, n+m);
         for(int i=0;i<m;i++)
            lines[n+i]=wrapped[i];
        }
     }

// ---------- draw each line as its own OBJ_TEXT (same color) ----------
   if(Inp_ShowLabels)
     {
      for(int i=0;i<ArraySize(lines); ++i)
        {
         string name = StringFormat("%s_LBL%d", s.id, i);
         double yi = s.is_buy ? (yBase + i*lineStep) : (yBase - i*lineStep);

         if(ObjectFind(0,name)<0)
            ObjectCreate(0, name, OBJ_TEXT, 0, t, yi);
         else
            ObjectMove(0, name, 0, t, yi);

         ObjectSetString(0, name, OBJPROP_TEXT, lines[i]);
         ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
         ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 9);
         ObjectSetInteger(0, name, OBJPROP_ANCHOR, s.is_buy?ANCHOR_LOWER:ANCHOR_UPPER);
         ObjectSetInteger(0, name, OBJPROP_BACK, false);
         ObjectSetInteger(0, name, OBJPROP_ZORDER, 1100);
         ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
        }
     }

   if(Inp_ShowArrows)
     {
      string arr = s.id+"_ARR";
      if(ObjectFind(0,arr)<0)
         ObjectCreate(0, arr, s.is_buy?OBJ_ARROW_BUY:OBJ_ARROW_SELL, 0, t, s.entry);
      else
         ObjectMove(0, arr, 0, t, s.entry);

      ObjectSetInteger(0, arr, OBJPROP_COLOR, clr);
      ObjectSetInteger(0, arr, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, arr, OBJPROP_BACK, false);
      ObjectSetInteger(0, arr, OBJPROP_ZORDER, 1000);
     }

   ChartRedraw();
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void SpawnSignalAt(const Candidate &c, const string &confirmTag, int ltfShift)
  {
   string id = MakeSigIdAt(c, ltfShift);
   for(int i=0;i<ArraySize(g_signals);++i)
      if(g_signals[i].id==id)
         return;

 // ---- time-anchored displacement hard gate (use the candidate's anchored value) ----
double disp_check = c.disp;
if((disp_check + 1e-9) < Inp_DisplacementMin) {
   if(Inp_LogToJournal)
      PrintFormat("[ZERO] Skip signal %s: displacement %.2f < min %.2f (%s %s)",
                  id, disp_check, Inp_DisplacementMin, TFToStr(c.htf), (c.is_buy?"BUY":"SELL"));
   return;
}


// --- thresholds (tune here; no new inputs) ---
   const double MIN_SL_SPREAD_MULT = 1.5;   // SL >= 1.5 * spread
   const double MIN_SL_ATR_MULT    = 0.10;  // SL >= 0.10 * ATR(LTF)
   const double MAX_SL_ATR_MULT    = 3.0;   // SL <= 3.0  * ATR(LTF)
   const double MIN_RR_REQ         = 1.2;   // minimum RR required

// --- market refs/vol ---
   const double spread   = GetSpreadPrice();
   const double atr_ltf  = ATR(TF_LTF(), 14);      // for small padding only
   const double atr_htf  = ATR(c.htf, 14);         // for SL size gating against HTF volatility
   const double pad      = MathMax(spread, atr_ltf*0.10);

   double entry = c.mid;
    bool   mfvgForcePending = false;
    string mfvgAnchorTag = "";
   double sl    = c.is_buy ? (c.bot - pad) : (c.top + pad);

   string anchorNm="", confirmLabel=confirmTag;
    if(Inp_EntryMode==Entry_Market && Inp_MFVG_MarketAdjust != MFVG_Adjust_Current)
      {
       string upperTag = Upper(confirmTag);
       if(StringFind(upperTag, "MFVG") >= 0)
         {
          double edgeNear, edgeFar;
          if(GetMicroFVGEdgesAt(c.is_buy, ltfShift, edgeNear, edgeFar))
            {
             double anchorRaw = (Inp_MFVG_MarketAdjust==MFVG_Adjust_Start ? edgeNear : (edgeNear + edgeFar)*0.5);
             double desired   = c.is_buy ? (anchorRaw + spread) : (anchorRaw - spread);
             double refNow    = c.is_buy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
             if(refNow>0.0)
               {
                double tol = _Point*0.5;
                if((c.is_buy && desired < refNow - tol) || (!c.is_buy && desired > refNow + tol))
                  {
                   entry = ToTick(desired);
                   mfvgForcePending = true;
                   mfvgAnchorTag = (Inp_MFVG_MarketAdjust==MFVG_Adjust_Start ? "MFVG(start)" : "MFVG(50%)");
                  }
               }
            }
         }
      }

// ===== MARKET: SL = last swing of confirmation leg =====
    if(Inp_EntryMode==Entry_Market)
     {
      double legSwing;
      if(FindLastLegSwing(c.is_buy, ltfShift, Inp_SW_Pivot, legSwing))
        {
         double slPad = spread * Inp_SL_Pad_SpreadMult;
         sl = c.is_buy ? (legSwing - slPad) : (legSwing + slPad);
         sl = ToTick(sl);
        }
     }

// ===== PENDING: anchor + leg swing (unchanged) =====
   if(Inp_EntryMode==Entry_PendingAtEntry)
     {
      double anchorRaw;
      if(ComputePendingAnchor(c, ltfShift, confirmTag, anchorRaw, anchorNm))
        {
         entry = c.is_buy ? (anchorRaw + spread) : (anchorRaw - spread);
         entry = ToTick(entry);

         double legSwing;
         if(FindLastLegSwing(c.is_buy, ltfShift, Inp_SW_Pivot, legSwing))
           {
            double slPad = spread * Inp_SL_Pad_SpreadMult;
            sl = c.is_buy ? (legSwing - slPad) : (legSwing + slPad);
            sl = ToTick(sl);
           }
        }
     }

    if(mfvgForcePending && StringLen(mfvgAnchorTag)>0 && StringLen(anchorNm)==0)
       anchorNm = mfvgAnchorTag;

    bool signalPending = (Inp_EntryMode==Entry_PendingAtEntry) || mfvgForcePending;

    if(StringLen(anchorNm)>0)
       confirmLabel = confirmTag + "(" + anchorNm + ")";

// --- risk & TPs (from final entry/sl) ---
   double risk = MathAbs(entry - sl);
   double tp1=0.0, tp2=0.0;
   if(Inp_RR_TP1>0.0)
      tp1 = c.is_buy ? (entry + risk*Inp_RR_TP1) : (entry - risk*Inp_RR_TP1);
   if(Inp_RR_TP2>0.0)
      tp2 = c.is_buy ? (entry + risk*Inp_RR_TP2) : (entry - risk*Inp_RR_TP2);

// ===== Filters: Min/Max SL & Min RR =====
   double minRisk = MathMax(MIN_SL_SPREAD_MULT*spread, MIN_SL_ATR_MULT*atr_htf);
   double maxRisk = MAX_SL_ATR_MULT*atr_htf;
   bool sl_ok = (risk >= minRisk && risk <= maxRisk);

   bool rr_ok = true;
   if(Inp_ExitMode==Exit_BE_Trail)
     {
      // In BE/Trail mode, allow entries even if immediate zone-edge RR < threshold;
      // trailing/BE logic manages risk post-entry.
      rr_ok = true;
     }
   else   // Exit_FixedTPs
     {
      double chosenRR = (Inp_OrderTP==Use_TP1? Inp_RR_TP1 : (Inp_OrderTP==Use_TP2? Inp_RR_TP2 : 0.0));
      if(chosenRR>0.0)
         rr_ok = (chosenRR >= MIN_RR_REQ);
     }

   bool allowTrade = (sl_ok && rr_ok);
   string fltInfo = allowTrade ? "OK" : StringFormat("BLOCK%s%s",(sl_ok?"":"(SL)"),(rr_ok?"":"(RR)"));

// ---- diagnostics (compact but rich) ----
   bool flags[];
   ArrayResize(flags,7);
   BuildAllConfsAt(c, ltfShift, flags);
   string flagsStr = BuildFlagsString(flags);
   int ftShift=-1;
   bool validated = IsZoneValidated(c.htf, c.is_buy, c.t1, c.top, c.bot, ftShift);

   const double spread_pts     = GetSpreadPoints();
   const double max_spread_pts = SpreadLimitPrice()/_Point;
   const double atr14_pts      = atr_ltf/_Point;
   const double R_pts          = risk/_Point;
    string mode                 = (signalPending ? "PEND" : "MKT");
   string bosChild             = TFToStr(ChildTFForBOS(TF_LTF()));


   string advanced = StringFormat(
                        "Zone[%s %s] top=%.*f bot=%.*f mid=%.*f | FT:%s s=%d | Cnf:%s [%s] | Mode:%s | Anchor:%s | Entry:%.*f SL:%.*f R=%.1fpt | TP1:%.*f TP2:%.*f | Bias H1/H4:%s/%s Loc:%s Disp:%.2f Sweep:%s Score:%.2f | Spread:%.0f/%.0fpt ATR14:%.0fpt | BOSchild:%s | Filters:%s",
                        TFToStr(c.htf), (c.is_buy? "BUY":"SELL"),
                        DigitsSym(), c.top, DigitsSym(), c.bot, DigitsSym(), c.mid,
                        (validated? "Y":"N"), (validated? ftShift:-1),
                        confirmLabel, flagsStr, mode, (StringLen(anchorNm)>0 ? anchorNm : "—"),
                        DigitsSym(), entry, DigitsSym(), sl, R_pts,
                        DigitsSym(), tp1, DigitsSym(), tp2,
                        Sign2(c.biasH1), Sign2(c.biasH4), (c.inLocation? "OK":"N/A"),
                        c.disp, Yn(c.swept), c.score,
                        spread_pts, max_spread_pts, atr14_pts, bosChild, fltInfo
                     );

// ---- pack & draw ----
   Signal s;
   s.id = id;
   s.is_buy=c.is_buy;
   s.htf=c.htf;
   s.when = iTime(_Symbol,TF_LTF(),ltfShift);
   s.entry=entry;
   s.sl=sl;
   s.tp1=tp1;
   s.tp2=tp2;
   s.confirm=confirmLabel;
   s.info=advanced;
   s.drawn=false;
   s.traded=false;
   s.pendingOverride = mfvgForcePending;
   s.ticket=0;
   s.z_t1=c.t1;
   s.z_top=c.top;
   s.z_bot=c.bot;
   s.z_disp  = c.disp;

   int n=ArraySize(g_signals);
   ArrayResize(g_signals,n+1);
   g_signals[n]=s;

   color clr = c.is_buy ? clrLime : clrTomato;
   if(Inp_DrawSLTP)
      DrawSLTP(s.id, entry, sl, tp1, tp2, clr);
   DrawSignalLabel(s, clr);
   g_signals[n].drawn=true;

// ---- place trade only if filters pass ----
   if(allowTrade)
      ExecuteTradeForSignal(n);
   if(Inp_LogToJournal && !Inp_LogOnlyTrades)
      PrintFormat("[ZERO] %s %s on %s | entry=%.*f sl=%.*f | Filters=%s | score=%.2f",
                  (c.is_buy?"BUY":"SELL"), s.id, TFToStr(c.htf),
                  DigitsSym(), s.entry, DigitsSym(), s.sl, fltInfo, c.score);

   TidySignalVisuals();
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string Trim(string s)
  {
   StringTrimLeft(s);
   StringTrimRight(s);
   return s;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string Upper(string s)
  {
   StringToUpper(s);
   return s;
  }




// ---- LTF confirmations at a specific bar shift (s=1 is last closed) ----
bool LTF_EngulfAt(bool is_buy, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+3, r, bars) || bars < s+2)
      return false;

   double curOpen  = r[s].open;
   double curClose = r[s].close;
   double prevOpen = r[s+1].open;
   double prevClose= r[s+1].close;

   double eps = MathMax(_Point*2.0, 1e-6);
   double curBody  = curClose - curOpen;
   double prevBody = prevClose - prevOpen;

   if(is_buy)
     {
      if(curBody <= eps)
         return false;
      if(prevBody >= -eps)
         return false;
      if(curOpen > prevClose + eps)
         return false;
      if(curClose < prevOpen - eps)
         return false;
      if(MathAbs(curBody) + eps < MathAbs(prevBody))
         return false;
      return true;
     }
   else
     {
      if(curBody >= -eps)
         return false;
      if(prevBody <= eps)
         return false;
      if(curOpen < prevClose - eps)
         return false;
      if(curClose > prevOpen + eps)
         return false;
      if(MathAbs(curBody) + eps < MathAbs(prevBody))
         return false;
      return true;
     }
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_WickRejectionAt(bool is_buy, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+2, r, bars) || bars < s+1)
      return false;
   double hi=r[s].high, lo=r[s].low, op=r[s].open, cl=r[s].close;
   double range = hi-lo;
   if(range<=0)
      return false;
   double lowerWick = MathMax(0.0, MathMin(op,cl)-lo);
   double upperWick = MathMax(0.0, hi - MathMax(op,cl));
   return is_buy ? (lowerWick >= 0.60*range && cl>op)
          : (upperWick >= 0.60*range && cl<op);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool LTF_MicroFVGAt(bool is_buy, int s)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF(TF_LTF(), s+4, r, bars) || bars < s+3)
      return false;
   return is_buy ? (r[s].low  > r[s+2].high)
          : (r[s].high < r[s+2].low);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool BuildCandidateFromZone(bool is_buy, ENUM_TIMEFRAMES tf,datetime t1,double top, double bot, double mid,Candidate &out)
  {
   out.valid=false;

// context: bias & location
   double legLowH1=0, legHighH1=0, legLowH4=0, legHighH4=0;
   int biasH1 = HTF_BiasAndRange(PERIOD_H1, Inp_SW_Pivot, legLowH1, legHighH1);
   int biasH4 = HTF_BiasAndRange(PERIOD_H4, Inp_SW_Pivot, legLowH4, legHighH4);

   double priceNow = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   bool locOK = InProperLocation(is_buy,
                                 priceNow,
                                 (tf==PERIOD_H1?legLowH1:legLowH4),
                                 (tf==PERIOD_H1?legHighH1:legHighH4));
   if(!Inp_RequireLocation)
      locOK = true;

// displacement & sweep based on bar that closed the gap
   double disp=0;
   if(!HTF_DisplacementFactor(tf, t1, disp))
      disp=0;
   if(disp < Inp_DisplacementMin)
      return false;
   bool swept = true;
   if(Inp_RequireHTF_Liq_Sweep){swept =  HTF_SweepHeuristic(tf, t1, is_buy);}

// distance filter (how far current price from mid)
   double atr = ATR(tf, Inp_ATR_Period);
   if(atr<=0)
      atr=1*_Point;
   bool withinZoneNow = (priceNow <= MathMax(top,bot) && priceNow >= MathMin(top,bot));
   int  tmpShift=-1;
   bool wasTouched = IsZoneValidated(tf, is_buy, t1, top, bot, tmpShift); // first-touch already happened?
   if(!withinZoneNow && !wasTouched)
     {
      if(MathAbs(priceNow - mid) > Inp_MaxDistATR*atr)
         return false;
     }

// ---------- NEW: HTF BOS filter around this FVG ----------
   bool bosBefore=false, bosAfter=false;
   double refLvl=0.0;
   bool bosEval=true;
   bosEval = HTF_BOS_AroundFVG(tf, t1, is_buy,
                               Inp_HTF_BOS_K, Inp_HTF_BOS_LookbackBars, Inp_HTF_BOS_LookaheadBars,
                               bosBefore, bosAfter, refLvl);

   if(Inp_RequireHTF_BOS)
     {
      bool pass=false;
      if(!bosEval)
        {
         pass = Inp_SoftBOS;   // allow if evaluation not possible and SoftBOS enabled
        }
      else
        {
         switch(Inp_HTF_BOS_Mode)
           {
            case HTF_BOS_Before:
               pass =  bosBefore;
               break;
            case HTF_BOS_After:
               pass =  bosAfter;
               break;
            case HTF_BOS_BeforeOrAfter:
               pass = (bosBefore || bosAfter);
               break;
            case HTF_BOS_Both:
               pass = (bosBefore && bosAfter);
               break;
           }
        }
      if(!pass)
         return false;  // reject if required and not satisfied
     }

// ---------- scoring (unchanged; OPTIONAL tiny BOS bonus) ----------
   double s_disp = MathMin(1.0, disp/2.0);
   double s_sweep= swept?1.0:0.0;
   double s_loc  = locOK?1.0:0.0;
   double s_bias = 0.0;
   if((is_buy && biasH1>0) || (!is_buy && biasH1<0))
      s_bias += 0.6;
   if((is_buy && biasH4>0) || (!is_buy && biasH4<0))
      s_bias += 0.4;

   double score = 0.35*s_disp + 0.20*s_sweep + 0.20*s_loc + 0.15*s_bias + 0.10;
// OPTIONAL: tiny bump if BOS condition present
   if(bosBefore || bosAfter)
      score += 0.03; // small, so your existing thresholds remain meaningful

   out.valid        = (score >= Inp_ScoreMin);
   out.is_buy       = is_buy;
   out.htf          = tf;
   out.t1           = t1;
   out.top          = top;
   out.bot          = bot;
   out.mid          = mid;
   out.disp         = disp;
   out.swept        = swept;
   out.biasH1       = biasH1;
   out.biasH4       = biasH4;
   out.inLocation   = locOK;
   out.score        = score;

// fill BOS fields
   out.bosBefore    = bosBefore;
   out.bosAfter     = bosAfter;
   out.bosRefLevel  = refLvl;

   return out.valid;
  }

//==================== TRADE ENGINE ====================//

// Find same-direction BOS around an HTF FVG.
// t1 = left bar time of the FVG (you already use this convention).
// For BUY: breaking a prior swing HIGH; for SELL: breaking a prior swing LOW.
bool HTF_BOS_AroundFVG(ENUM_TIMEFRAMES tf, datetime t1_left, bool is_buy,
                       int k, int lookbackBars, int lookaheadBars,
                       bool &bosBefore, bool &bosAfter, double &refLevelOut)
  {
   bosBefore=false;
   bosAfter=false;
   refLevelOut=0.0;

// Pull enough bars to cover both windows with margin
   MqlRates r[];
   int bars;
   int need = MathMax(120, lookbackBars + lookaheadBars + 60);
   if(!CopyRatesTF(tf, need, r, bars) || bars < (2*k + 10))
      return false;

// Index of the bar that CLOSED the gap (you already use this in HTF_DisplacementFactor)
   int idxLeft = iBarShift(_Symbol, tf, t1_left, true);
   int sClose  = idxLeft - 1;                        // "right" (closing) bar of the gap
   if(sClose < k || sClose >= bars-1)
      return false;  // out of bounds

// 1) Find the nearest PRIOR swing in the BOS direction (before the gap)
// Window: from just before the closing bar back to 'lookbackBars'
   int from = sClose + 1;
   int to   = MathMin(bars-1-k, sClose + lookbackBars);
   double refLevel=0.0;
   bool foundSwing=false;

   for(int i=from; i<=to; ++i)
     {
      if(is_buy)
        {
         if(IsSwingHigh(r, i, k))
           {
            refLevel = r[i].high;
            foundSwing=true;
            break;
           }
        }
      else
        {
         if(IsSwingLow(r, i, k))
           {
            refLevel = r[i].low;
            foundSwing=true;
            break;
           }
        }
     }
// Fallback: if no clean swing, use the prior window extreme
   if(!foundSwing)
     {
      double hi=r[from].high, lo=r[from].low;
      for(int i=from; i<=to; ++i)
        {
         if(r[i].high>hi)
            hi=r[i].high;
         if(r[i].low<lo)
            lo=r[i].low;
        }
      refLevel = is_buy ? hi : lo;
     }
   refLevelOut = refLevel;

// 2) BOS BEFORE the FVG: any close in (older) bars BEFORE sClose that already broke refLevel?
// Older bars have BIGGER indices because ArraySetAsSeries(r,true).
   for(int i=from; i<=to; ++i)
     {
      double cl = r[i].close;
      if((is_buy && cl > refLevel) || (!is_buy && cl < refLevel))
        {
         bosBefore = true;
         break;
        }
     }

// 3) BOS AFTER the FVG: any close in NEWER bars (after sClose) that breaks the same ref?
   int a_from = sClose-1;
   int a_to   = MathMax(1, sClose - lookaheadBars);
   for(int j=a_from; j>=a_to; --j)
     {
      double cl = r[j].close;
      if((is_buy && cl > refLevel) || (!is_buy && cl < refLevel))
        {
         bosAfter = true;
         break;
        }
     }

   return true;
  }
//===================== END OF HTF BOS /SWING CHECKS =====================//

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// int FindFirstTouchShiftInWindow(const Candidate &C, int backN)
//   {
// // scan oldest->newest to capture the true first touch
//    for(int s=backN; s>=1; --s)
//      {
//       bool touched = Inp_FirstTouchStrict
//                      ? LTF_EnteredZoneThisBar(C.is_buy, C.top, C.bot, s)
//                      : LTF_TouchedZoneAt(C.top, C.bot, s);
//       if(touched)
//         {
//          if(Inp_StartOnCloseInside)
//            {
//             if(!LTF_ClosedInsideZoneAt(C.top, C.bot, s))
//                continue; // require a close inside the zone
//            }
//          return s;
//         }
//      }
//    return -1;
//   }
int FindFirstTouchShiftInWindow(const Candidate &C, int backN)
{
   // --- only allow touches AFTER the HTF gap-closing bar has closed ---
   int left  = iBarShift(_Symbol, C.htf, C.t1, true);
   if(left <= 0) return -1;
   int right = left - 2;                     // right bar of the FVG
   if(right < 0) return -1;
   datetime t_right_open  = iTime(_Symbol, C.htf, right);
   datetime t_after_close = t_right_open + PeriodSeconds(C.htf);

   // scan oldest -> newest in the window
   for(int s = backN; s >= 1; --s)
   {
      datetime tbar = iTime(_Symbol, TF_LTF(), s);  // LTF bar open time
      if(tbar <= t_after_close)
         continue;                 // ignore bars that belong to/precede FVG formation
    
      // if(Inp_UseSessionFilter && !IsTradingSessionAt(tbar)) continue; // NEW

      bool touched = Inp_FirstTouchStrict
                     ? LTF_EnteredZoneThisBar(C.is_buy, C.top, C.bot, s)
                     : LTF_TouchedZoneAt(C.top, C.bot, s);
      if(!touched) continue;

      if(Inp_StartOnCloseInside && !LTF_ClosedInsideZoneAt(C.top, C.bot, s))
         continue;

      return s;                    // first valid post-formation touch
   }
   return -1;
}



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
//==Issue Is It Trade Even on Mittigated Zones (HTF)=================//

// void EvaluateTradeOpportunities()
//   {
//    if(!Inp_EnableSignals)
//      {
//       DebugPanel("Signals /Oportunities disabled");
//       return;
//      }

// // ---- global daily loss guard
//    if(DailyLossHit())
//      {
//       DebugPanel("Trading paused: daily loss limit hit.");
//       return;
//      }

// // ---- weekend new-trade guard
//    if(BlockNewForWeekend())
//      {
//       DebugPanel("No signals: weekend protection active.");
//       return;
//      }

// // ---- spread guard
//    const double sp_price = GetSpreadPrice();
//    const double lim      = SpreadLimitPrice();
//    if(sp_price > lim)
//      {
//       DebugPanel(StringFormat("No signals: spread=%.5f > max=%.5f", sp_price, lim));
//       return;
//      }

// // ---- session guard
//    if(!IsTradingSessionNow())
//      {
//       DebugPanel("No signals: outside allowed session (London + first half NY).");
//       return;
//      }

// // ---- news guard (simple schedule ± window)
//    if(IsNewsBlockNow())
//      {
//       DebugPanel("No signals: high-impact news window.");
//       return;
//      }

// // ---- run once per CLOSED bar on the evaluation LTF (per Inp_HTFMode)
//    ENUM_TIMEFRAMES gateTF = PERIOD_M5;
//    switch(Inp_HTFMode)
//      {
//       case HTF_H1_M5:
//          gateTF = PERIOD_M5;
//          break;
//       case HTF_H4_M15:
//          gateTF = PERIOD_M15;
//          break;
//       case HTF_BOTH:
//       case HTF_ANY:
//          gateTF = PERIOD_M5;
//          break; // frequent gate
//       case HTF_M15_M1:
//          gateTF = PERIOD_M1;
//          break; // scalper gate
//      }
//    datetime ltfClosed = iTime(_Symbol, gateTF, 1);

//    if(ltfClosed==0)
//      {
//       DebugPanel("Waiting for bars...");
//       return;
//      }
//    if(ltfClosed==g_lastLTFClosed)
//      {
//       // DebugPanel("Waiting new LTF close...");
//       return;
//      }
//    g_lastLTFClosed = ltfClosed;

// // ---------- build candidate pool (HTFs from inputs, both sides) ----------
//    Candidate pool[];
//    ArrayResize(pool,0);

// // ---- build TF list for TRADING from Inp_HTFMode (Inp_TFs deprecated) ----
//    ENUM_TIMEFRAMES tradeTFs[];
//    ArrayResize(tradeTFs,0);
//    switch(Inp_HTFMode)
//      {
//       case HTF_H1_M5:
//         { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_H1; }
//       break;
//       case HTF_H4_M15:
//         { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_H4; }
//       break;
//       case HTF_BOTH:
//       case HTF_ANY:
//         { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+2); tradeTFs[k]=PERIOD_H1; tradeTFs[k+1]=PERIOD_H4; }
//       break;
//       case HTF_M15_M1:
//         { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_M15; }
//       break;
//      }
//    if(ArraySize(tradeTFs)==0)
//      {
//       int k=ArraySize(tradeTFs);
//       ArrayResize(tradeTFs,k+1);
//       tradeTFs[k]=PERIOD_H1;
//      }

//    bool sides[2]= {true,false}; // buy, sell

//    for(int ti=0; ti<ArraySize(tradeTFs); ++ti)
//      {
//       ENUM_TIMEFRAMES tf = tradeTFs[ti];
//       MqlRates r[];
//       int bars = CopyRates(_Symbol, tf, 0, MathMax(Inp_LookbackBars,600), r);
//       if(bars<5)
//          continue;
//       ArraySetAsSeries(r,true);

//       for(int s=1; s<=bars-3; ++s)
//         {
//          double low_r  = r[s].low,  high_r = r[s].high;
//          double low_l  = r[s+2].low, high_l = r[s+2].high;

//          for(int si=0; si<2; ++si)
//            {
//             const bool is_buy = sides[si];
//             bool ok=false;
//             double lower=0, upper=0;

//             if(is_buy)
//               {
//                if(low_r > high_l)
//                  {
//                   lower=high_l;
//                   upper=low_r;
//                   ok=true;
//                  }
//               }
//             else
//               {
//                if(high_r < low_l)
//                  {
//                   lower=high_r;
//                   upper=low_l;
//                   ok=true;
//                  }
//               }
//             if(!ok)
//                continue;
//             if(!PassesSizeFilter(tf, lower, upper))
//                continue;

//             const double top=upper, bot=lower, mid=0.5*(top+bot);
//             const datetime t1 = r[s+2].time;

//             // ignore zones we already retired
//             if(IsRetired(tf,is_buy,t1,top,bot))
//                continue;

//             Candidate c;
//             if(IsRetired(tf, is_buy, t1, top, bot) || IsMitigated_HTF(top, bot, is_buy, tf))
//                {continue;}
//             if(BuildCandidateFromZone(is_buy, tf, t1, top, bot, mid, c))
//               {
              
//                bool include=true;
//                if(Inp_TradeOnlyVisibleZones)
//                  {
//                   if(tf==PERIOD_H1 || tf==PERIOD_H4 || tf==PERIOD_M15)
//                     {
//                      int ti = TFSlot(tf);
//                      int si = SideSlot(is_buy);
//                      include = SameZone(g_htf[ti][si], t1, top, bot);
//                     }
//                  }
//                if(include)
//                  {
//                   int k=ArraySize(pool);
//                   ArrayResize(pool,k+1);
//                   pool[k]=c;
//                  }
//               }
//            }
           
//         }
//      }

// // ---------- sort pool by score (desc) ----------
//    for(int i=0;i<ArraySize(pool);++i)
//      {
//       int best=i;
//       for(int j=i+1;j<ArraySize(pool);++j)
//          if(pool[j].score>pool[best].score)
//             best=j;
//       if(best!=i)
//         {
//          Candidate tmp=pool[i];
//          pool[i]=pool[best];
//          pool[best]=tmp;
//         }
//      }

// // ---------- fire signals with hard cap and per-zone-per-bar dedupe ----------
//    const int MAX_DRAW = MathMax(0, Inp_MaxSignalLabels);
//    int total_drawn = 0;
//    string seen_keys[];
//    ArrayResize(seen_keys, 0);

//    for(int i=0; i<ArraySize(pool) && total_drawn<MAX_DRAW; ++i)
//      {
//       // --- select candidate BEFORE using it
//       Candidate C = pool[i];
//       if(!C.valid)
//          continue;
//       if(IsRetired(C.htf, C.is_buy, C.t1, C.top, C.bot))
//          continue;

//       // --- pick LTF per HTF (H1→M5, H4→M15), else fall back to chart TF
//       ENUM_TIMEFRAMES evalTF =
//          (C.htf==PERIOD_H1  ? PERIOD_M5  :
//           (C.htf==PERIOD_H4  ? PERIOD_M15 :
//            (C.htf==PERIOD_M15 ? PERIOD_M1  : (ENUM_TIMEFRAMES)_Period)));

//       g_evalOverride = true;
//       g_evalTF       = evalTF;

//       // use a per-candidate backfill window in that eval TF
//       int barsEval   = iBars(_Symbol, evalTF);
//       int backN_eval = MathMax(1, MathMin(Inp_BackfillBars, barsEval-2));

//       // --- VALIDATION: require/allow tracking first touch before confirmations
//       bool seekAfterTouch = (Inp_OnlyTradeOnFreshTouch || Inp_KeepSeekingAfterTouch);
//       int  ftShift   = -1;
//       bool validated = seekAfterTouch
//                        ? IsZoneValidated(C.htf, C.is_buy, C.t1, C.top, C.bot, ftShift)
//                        : true;

//       if(seekAfterTouch && !validated)
//         {
//          // search the current backfill window for the most recent first-touch bar
//          int found = FindFirstTouchShiftInWindow(C, backN_eval);
//          if(found<0)
//            {
//             g_evalOverride=false;   // not touched yet
//             continue;
//            }
//          MarkZoneValidated(C.htf, C.is_buy, C.t1, C.top, C.bot, found);
//          ftShift   = found;
//          validated = true;
//         }

//       // bars we will evaluate confirmations on:
//       //  * If seekAfterTouch: only the first-touch bar and any newer bars (s <= ftShift)
//       //  * Else (legacy): only bars that directly touch on s
//       for(int s=1; s<=backN_eval && total_drawn<MAX_DRAW; ++s)
//         {
//          bool barAllowed;
//          if(seekAfterTouch)
//            {
//             if(!validated)
//                break;
//             barAllowed = (s <= ftShift);
//            }
//          else
//            {
//             barAllowed = LTF_TouchedZoneAt(C.top, C.bot, s);
//            }
//          if(!barAllowed)
//             continue;

//          // confirmation on this bar?
//          string tag;
//          // Enable post-touch gating so confirmations never use pre-touch bars
//          int prevGate = g_ftShiftActive;
//          g_ftShiftActive = (seekAfterTouch ? ftShift : -1);
//          bool okConf = LTF_ConfirmationAt2(C, s, tag);
//          g_ftShiftActive = prevGate;
//          if(!okConf)
//             continue;

//          // one-trade-per-zone guard (optional)
//          if(!Inp_AllowMultiplePerZone && IsZoneAlreadyTraded(C.htf, C.is_buy, C.t1, C.top, C.bot))
//             continue;

//          // per-bar de-dupe (use the active eval TF via TF_LTF())
//          datetime tbar = iTime(_Symbol, TF_LTF(), s);
//          string key = StringFormat("%s|%c|%I64d|%.8f|%.8f|%I64d",
//                                    TFToStr(C.htf), (C.is_buy?'B':'S'),
//                                    (long)C.t1, C.top, C.bot, (long)tbar);
//          bool seen=false;
//          for(int kk=0; kk<ArraySize(seen_keys); ++kk)
//            {
//             if(seen_keys[kk]==key)
//               {
//                seen=true;
//                break;
//               }
//            }
//          if(seen)
//             continue;

//          // Backfill trade suppression (still draw the label)
//          bool restoreSupp=false;
//          if(Inp_DoNotTradeBackfill && s>1)
//            {
//             g_suppressAutoTrade=true;
//             restoreSupp=true;
//            }

//          // draw & (optionally) trade
//          //Final Check If Retired, Mitigated, or Traded or Traded Already
//          if(IsRetired(C.htf, C.is_buy, C.t1, C.top, C.bot) || IsMitigated_HTF(C.top, C.bot, C.is_buy, C.htf) || IsZoneAlreadyTraded(C.htf, C.is_buy, C.t1, C.top, C.bot))
//            {
//             g_evalOverride=false;
//             if(restoreSupp)
//                g_suppressAutoTrade=false;
//             continue;
//            }

//          SpawnSignalAt(C, tag, s);

//          if(restoreSupp)
//             g_suppressAutoTrade=false;

//          int n_seen=ArraySize(seen_keys);
//          ArrayResize(seen_keys, n_seen+1);
//          seen_keys[n_seen]=key;
//          total_drawn++;
//         }

//       // reset override for safety on each iteration
//       g_evalOverride=false;
//      }

// // final safety
//    g_evalOverride=false;

//    string dbg = StringFormat("LTFclose:%s  Pool:%d  Plotted:%d (cap=%d)",
//                              TimeToString(ltfClosed, TIME_MINUTES|TIME_SECONDS),
//                              ArraySize(pool), total_drawn, MAX_DRAW);
//    DebugPanel(dbg);
//    TidySignalVisuals();
//   }

//NO TRADE IN THIS VERSION
 void EvaluateTradeOpportunities()
  {
   if(!Inp_EnableSignals)
     {
      DebugPanel("Signals /Oportunities disabled");
      return;
     }

// ---- global daily loss guard
   if(DailyLossHit())
     {
      DebugPanel("Trading paused: daily loss limit hit.");
      return;
     }

// ---- weekend new-trade guard
   if(BlockNewForWeekend())
     {
      DebugPanel("No signals: weekend protection active.");
      return;
     }

// ---- spread guard
   const double sp_price = GetSpreadPrice();
   const double lim      = SpreadLimitPrice();
   if(sp_price > lim)
     {
      DebugPanel(StringFormat("No signals: spread=%.5f > max=%.5f", sp_price, lim));
      return;
     }
 

// ---- news guard (simple schedule ± window)
   if(IsNewsBlockNow())
     {
      DebugPanel("No signals: high-impact news window.");
      return;
     }

// ---- run once per CLOSED bar on the evaluation LTF (per Inp_HTFMode)
   ENUM_TIMEFRAMES gateTF = PERIOD_M5;
   switch(Inp_HTFMode)
     {
      case HTF_H1_M5:
         gateTF = PERIOD_M5;
         break;
      case HTF_H4_M15:
         gateTF = PERIOD_M15;
         break;
      case HTF_BOTH:
      case HTF_ANY:
         gateTF = PERIOD_M5;
         break; // frequent gate
      case HTF_M15_M1:
         gateTF = PERIOD_M1;
         break; // scalper gate
     }
   datetime ltfClosed = iTime(_Symbol, gateTF, 1);

   if(ltfClosed==0)
     {
      //DebugPanel("Waiting for bars...");
      return;
     }
   if(ltfClosed==g_lastLTFClosed)
     {
      // DebugPanel("Waiting new LTF close...");
      return;
     }
   g_lastLTFClosed = ltfClosed;

// ---------- build candidate pool (HTFs from inputs, both sides) ----------
   Candidate pool[];
   ArrayResize(pool,0);

// ---- build TF list for TRADING from Inp_HTFMode (Inp_TFs deprecated) ----
   ENUM_TIMEFRAMES tradeTFs[];
   ArrayResize(tradeTFs,0);
   switch(Inp_HTFMode)
     {
      case HTF_H1_M5:
        { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_H1; }
      break;
      case HTF_H4_M15:
        { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_H4; }
      break;
      case HTF_BOTH:
      case HTF_ANY:
        { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+2); tradeTFs[k]=PERIOD_H1; tradeTFs[k+1]=PERIOD_H4; }
      break;
      case HTF_M15_M1:
        { int k=ArraySize(tradeTFs); ArrayResize(tradeTFs,k+1); tradeTFs[k]=PERIOD_M15; }
      break;
     }
   if(ArraySize(tradeTFs)==0)
     {
      int k=ArraySize(tradeTFs);
      ArrayResize(tradeTFs,k+1);
      tradeTFs[k]=PERIOD_H1;
     }

   bool sides[2]= {true,false}; // buy, sell

   for(int ti=0; ti<ArraySize(tradeTFs); ++ti)
     {
      ENUM_TIMEFRAMES tf = tradeTFs[ti];
      MqlRates r[];
      int bars = CopyRates(_Symbol, tf, 0, MathMax(Inp_LookbackBars,600), r);
      if(bars<5)
         continue;
      ArraySetAsSeries(r,true);

      for(int s=1; s<=bars-3; ++s)
        {
         double low_r  = r[s].low,  high_r = r[s].high;
         double low_l  = r[s+2].low, high_l = r[s+2].high;

         for(int si=0; si<2; ++si)
           {
            const bool is_buy = sides[si];
            bool ok=false;
            double lower=0, upper=0;

            if(is_buy)
              {
               if(low_r > high_l)
                 {
                  lower=high_l;
                  upper=low_r;
                  ok=true;
                 }
              }
            else
              {
               if(high_r < low_l)
                 {
                  lower=high_r;
                  upper=low_l;
                  ok=true;
                 }
              }
            if(!ok)
               continue;
            if(!PassesSizeFilter(tf, lower, upper))
               continue;

            const double top=upper, bot=lower, mid=0.5*(top+bot);
            const datetime t1 = r[s+2].time;

            // ignore zones we already retired
            if(IsRetired(tf,is_buy,t1,top,bot))
               continue;

            Candidate c;
            if(IsRetired(tf, is_buy, t1, top, bot) || IsMitigated_HTF(top, bot, is_buy, tf))
               {continue;}
         
               if(BuildCandidateFromZone(is_buy, tf, t1, top, bot, mid, c))
                  {
                     // default allow unless you're enforcing "visible only"
                     bool include = !Inp_TradeOnlyVisibleZones;
                  
                     if(Inp_TradeOnlyVisibleZones && (tf==PERIOD_H1 || tf==PERIOD_H4 || tf==PERIOD_M15))
                     {
                        int tfslot = TFSlot(tf);
                        int sslot  = SideSlot(is_buy);
                     
                        bool overlayOK = false;
                        
                        // --- SAFE bounds check before touching g_htf
                        int rows = ArrayRange(g_htf, 0);
                        int cols = ArrayRange(g_htf, 1);
                        if(tfslot >= 0 && tfslot < rows &&
                           sslot >= 0 && sslot < cols)
                        {
                           if(g_htf[tfslot][sslot].inited && !g_htf[tfslot][sslot].retired &&
                              SameZone(g_htf[tfslot][sslot], t1, top, bot) &&
                              !IsMitigated_HTF(top, bot, is_buy, tf))
                           {
                              overlayOK = true;
                           }
                        }
                     
                        // --- Fallback: verify the actual rectangle exists on the chart
                        if(!overlayOK)
                        {
                           string tfs  = (tf==PERIOD_H1 ? "H1" : (tf==PERIOD_H4 ? "H4" : "M15"));
                           string base = StringFormat("HTF_%s_FVG_%s_%s",
                                                      tfs, (is_buy?"BUY":"SELL"),
                                                      TimeToString(t1, TIME_DATE|TIME_MINUTES));
                           if(ObjectFind(0, base) >= 0 && !IsMitigated_HTF(top, bot, is_buy, tf))
                              overlayOK = true;
                        }
                     
                        include = overlayOK;
                     }
                  
                     if(!include)
                        continue;
                  
                     int k = ArraySize(pool);
                     ArrayResize(pool, k+1);
                     pool[k] = c;
                  }

           }
           
        }
     }

// ---------- sort pool by score (desc) ----------
   for(int i=0;i<ArraySize(pool);++i)
     {
      int best=i;
      for(int j=i+1;j<ArraySize(pool);++j)
         if(pool[j].score>pool[best].score)
            best=j;
      if(best!=i)
        {
         Candidate tmp=pool[i];
         pool[i]=pool[best];
         pool[best]=tmp;
        }
     }

// ---------- fire signals with hard cap and per-zone-per-bar dedupe ----------
   const int MAX_DRAW = MathMax(0, Inp_MaxSignalLabels);
   int total_drawn = 0;
   string seen_keys[];
   ArrayResize(seen_keys, 0);

   for(int i=0; i<ArraySize(pool) && total_drawn<MAX_DRAW; ++i)
     {
      // --- select candidate BEFORE using it
      Candidate C = pool[i];
      if(!C.valid)
         continue;
      if(IsRetired(C.htf, C.is_buy, C.t1, C.top, C.bot))
         continue;

      // --- pick LTF per HTF (H1→M5, H4→M15), else fall back to chart TF
      ENUM_TIMEFRAMES evalTF =
         (C.htf==PERIOD_H1  ? PERIOD_M5  :
          (C.htf==PERIOD_H4  ? PERIOD_M15 :
           (C.htf==PERIOD_M15 ? PERIOD_M1  : (ENUM_TIMEFRAMES)_Period)));

      g_evalOverride = true;
      g_evalTF       = evalTF;

      // use a per-candidate backfill window in that eval TF
      int barsEval   = iBars(_Symbol, evalTF);
      int backN_eval = MathMax(1, MathMin(Inp_BackfillBars, barsEval-2));

      // --- VALIDATION: require/allow tracking first touch before confirmations
      bool seekAfterTouch = (Inp_OnlyTradeOnFreshTouch || Inp_KeepSeekingAfterTouch);
      int  ftShift   = -1;
      bool validated = seekAfterTouch
                       ? IsZoneValidated(C.htf, C.is_buy, C.t1, C.top, C.bot, ftShift)
                       : true;

      if(seekAfterTouch && !validated)
        {
         // search the current backfill window for the most recent first-touch bar
         int found = FindFirstTouchShiftInWindow(C, backN_eval);
         if(found<0)
           {
            g_evalOverride=false;   // not touched yet
            continue;
           }
         MarkZoneValidated(C.htf, C.is_buy, C.t1, C.top, C.bot, found);
         ftShift   = found;
         validated = true;
        }

      // bars we will evaluate confirmations on:
      //  * If seekAfterTouch: only the first-touch bar and any newer bars (s <= ftShift)
      //  * Else (legacy): only bars that directly touch on s
      for(int s=1; s<=backN_eval && total_drawn<MAX_DRAW; ++s)
        {
         bool barAllowed;
         if(seekAfterTouch)
           {
            if(!validated)
               break;
            barAllowed = (s <= ftShift);
           }
         else
           {
            barAllowed = LTF_TouchedZoneAt(C.top, C.bot, s);
           }
         if(!barAllowed)
            continue;

         // confirmation on this bar?
         string tag;
         // Enable post-touch gating so confirmations never use pre-touch bars
         int prevGate = g_ftShiftActive;
         g_ftShiftActive = (seekAfterTouch ? ftShift : -1);
         bool okConf = LTF_ConfirmationAt2(C, s, tag);
         g_ftShiftActive = prevGate;
         if(!okConf)
            continue;

         // one-trade-per-zone guard (optional)
         if(!Inp_AllowMultiplePerZone && IsZoneAlreadyTraded(C.htf, C.is_buy, C.t1, C.top, C.bot))
            continue;

         // per-bar de-dupe (use the active eval TF via TF_LTF())
         datetime tbar = iTime(_Symbol, TF_LTF(), s);

         // skip confirmations whose bar-time is outside session
         // if(Inp_UseSessionFilter && !IsTradingSessionAt(tbar))continue; 


         string key = StringFormat("%s|%c|%I64d|%.8f|%.8f|%I64d",
                                   TFToStr(C.htf), (C.is_buy?'B':'S'),
                                   (long)C.t1, C.top, C.bot, (long)tbar);
         bool seen=false;
         for(int kk=0; kk<ArraySize(seen_keys); ++kk)
           {
            if(seen_keys[kk]==key)
              {
               seen=true;
               break;
              }
           }
         if(seen)
            continue;

         // Backfill trade suppression (still draw the label)
         bool restoreSupp=false;
         if(Inp_DoNotTradeBackfill && s>1)
           {
            g_suppressAutoTrade=true;
            restoreSupp=true;
           }

         // draw & (optionally) trade
         //Final Check If Retired, Mitigated, or Traded or Traded Already
         if(IsRetired(C.htf, C.is_buy, C.t1, C.top, C.bot) || IsMitigated_HTF(C.top, C.bot, C.is_buy, C.htf) || (!Inp_AllowMultiplePerZone &&IsZoneAlreadyTraded(C.htf, C.is_buy, C.t1, C.top, C.bot)))
           {
            g_evalOverride=false;
            if(restoreSupp)
               g_suppressAutoTrade=false;
            continue;
           }

         SpawnSignalAt(C, tag, s);

         if(restoreSupp)
            g_suppressAutoTrade=false;

         int n_seen=ArraySize(seen_keys);
         ArrayResize(seen_keys, n_seen+1);
         seen_keys[n_seen]=key;
         total_drawn++;
        }

      // reset override for safety on each iteration
      g_evalOverride=false;
     }

// final safety
   g_evalOverride=false;

   // string dbg = StringFormat("LTFclose:%s  Pool:%d  Plotted:%d (cap=%d)",
   //                           TimeToString(ltfClosed, TIME_MINUTES|TIME_SECONDS),
   //                           ArraySize(pool), total_drawn, MAX_DRAW);
   // DebugPanel(dbg);
   TidySignalVisuals();
  }



// ======= EXECUTOR (hardened, with SL/TP enforcement) =======
void ExecuteTradeForSignal(int idx)
  {
   if(!Inp_TradeLive)
      return;

       // hard gate at execution time
      // ---- SESSION GATE #1: block if "now" is outside session ----
   if(Inp_UseSessionFilter && !IsTradingSessionAt(TimeCurrent()))
   {
      Print("[ZERO] Trade blocked: outside allowed session (now).");
      return;
   }

   if(g_suppressAutoTrade)
     {
      g_suppressAutoTrade=false;
      return;
     }
   if(idx<0 || idx>=ArraySize(g_signals))
      return;
   if(g_signals[idx].traded)
      return;

   if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
     {
      Print("[ZERO] Trading not allowed by terminal.");
      return;
     }
   if(!MQLInfoInteger(MQL_TRADE_ALLOWED))
     {
      Print("[ZERO] Trading not allowed for this program (Algo Trading OFF).");
      return;
     }

   ConfigureTrade();

   Signal s = g_signals[idx];
   bool usePending = (Inp_EntryMode==Entry_PendingAtEntry) || s.pendingOverride;
   string modeStr = usePending ? "PEND" : "MKT";

// ----- short comment -----
   string conf="";
   string src=Upper(s.confirm);
   string tags[7]= {"ENGULF","MFVG","BOS","SFP","RETEST","IB","WICK"};
   string code[7]= {"E","M","B","F","R","I","W"};
   for(int i=0;i<7 && StringLen(conf)<3;i++)
      if(StringFind(src,tags[i])>=0)
         conf+=code[i];
   if(StringLen(conf)==0)
      conf="NA";
   char ft='?';
   int p=StringFind(s.info,"FT:");
   if(p>=0 && p+3<StringLen(s.info))
     {
      int ch=StringGetCharacter(s.info,p+3);
      if(ch=='Y'||ch=='N')
         ft=(char)ch;
     }
   string tf=TFToStr(s.htf);
   string bs=s.is_buy?"B":"S";
   string tpUse=(Inp_ExitMode==Exit_BE_Trail?"BE":(Inp_OrderTP==Use_TP1?"TP1":(Inp_OrderTP==Use_TP2?"TP2":"NT")));
   string idTail=s.id;
   if(StringLen(idTail)>6)
      idTail=StringSubstr(idTail,StringLen(idTail)-6);
   string ordComment=StringFormat("%s|%s|C:%s|%s|FT:%c|%s", tf, bs, conf, tpUse, ft, idTail);
   if(StringLen(ordComment)>63)
      ordComment=StringSubstr(ordComment,0,63);

// ----- conflict / duplicates -----
   CloseOppositePositionsIfNeeded(s.is_buy);
   CancelOppositePendingsIfNeeded(s.is_buy);
   if(HasSimilarActiveOrderOrPosition(s.is_buy, s.entry))
     {
      Print("[ZERO] Duplicate trade prevented.");
      g_signals[idx].traded=true;
      return;
     }

// --- encode compact magic (HTF BOS type, LTF confirms, pair id)
   if(Inp_UsePackedMagic)
     {
      uchar bits=0, pairId=0;
      uchar bosT = ComputeBOSType(s.is_buy, s.htf, s.z_t1);
      BuildConfirmBits(s.confirm, bits, pairId);
      ulong magicPacked = MagicPack(bits, pairId, bosT);
      // apply per-order magic (restore after placing)
      Trade.SetExpertMagicNumber(magicPacked);
     }

// ----- refs -----
   const double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
   const double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   const double ref_now=(s.is_buy?ask:bid);
   const double entry_px=ND(s.entry);
   const double ref_px = usePending ? entry_px : ref_now;

// ----- initial SL/TP -----
   double sl=s.sl, tp=0.0;
   FixStopsToLevels(ref_px, s.is_buy, sl, tp);

   const double R=MathAbs(ref_px-sl);
   double tp1_ref=0.0, tp2_ref=0.0;
   if(Inp_RR_TP1>0.0)
      tp1_ref=s.is_buy?(ref_px+R*Inp_RR_TP1):(ref_px-R*Inp_RR_TP1);
   if(Inp_RR_TP2>0.0)
      tp2_ref=s.is_buy?(ref_px+R*Inp_RR_TP2):(ref_px-R*Inp_RR_TP2);
   switch(Inp_ExitMode)
     {
      case Exit_FixedTPs:
         tp= (Inp_OrderTP==Use_TP1?tp1_ref:(Inp_OrderTP==Use_TP2?tp2_ref:0.0));
         break;
      case Exit_BE_Trail:
         tp=0.0;
         break;
     }
   if(tp>0.0)
      FixStopsToLevels(ref_px, s.is_buy, sl, tp);

// ----- lots -----
   bool hitCap=false;
   double lots=LotSizer_One(ref_px, sl, hitCap);
   if(lots<=0.0)
     {
      Print("[ZERO] LotSizer returned 0 — aborting trade.");
      return;
     }
   if(Inp_BlockWhenCapped && hitCap)
     {
      Print("[ZERO] Lots hit cap — blocked.");
      return;
     }

// ---- HARD RISK CAP for Lot_Fixed using Inp_RiskPerTradePct (minimal change) ----
   if(Inp_LotMode == Lot_Fixed && Inp_RiskPerTradePct > 0.0)
     {
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      if(tickValue > 0.0 && tickSize > 0.0)
        {
         double stopDist   = MathMax(MathAbs(ref_px - sl), tickSize);
         double ticks      = stopDist / tickSize;
         double impliedRisk= lots * ticks * tickValue;

         double base   = Inp_RiskUseEquity ? AccountInfoDouble(ACCOUNT_EQUITY)
                         : AccountInfoDouble(ACCOUNT_BALANCE);
         double capUSD = base * (Inp_RiskPerTradePct / 100.0);

         if(impliedRisk > capUSD)
           {
            // required lots to respect the cap
            double wantLots = capUSD / (ticks * tickValue);

            // round & clamp to broker limits
            double stepB = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
            double minB  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
            double maxB  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
            if(stepB <= 0.0)
               stepB = 0.01;

            wantLots = MathFloor(wantLots/stepB)*stepB;
            wantLots = MathMax(minB, MathMin(maxB, wantLots));

            if(wantLots < minB + 1e-12)
              {
               PrintFormat("[ZERO] Risk cap %.2f%% would require lots < min(%.4f). Skipping trade.",
                           Inp_RiskPerTradePct, minB);
               return;
              }

            if(Inp_DebugLotSizing)
               PrintFormat("[ZERO] Hard risk cap: implied=%.2f > cap=%.2f -> lots %.3f -> %.3f",
                           impliedRisk, capUSD, lots, wantLots);

            lots = NormalizeDouble(wantLots, (int)MathMax(0, MathRound(-MathLog10(stepB))));
           }
        }
     }



// ----- place -----
   bool  ok=false, placed_without_stops=false;
   ulong ticket=0;
   double placed_price=0.0;

   if(!usePending)
     {
      ok=PlaceMarketWithFallback(s.is_buy,lots,sl,tp,ordComment);
      ticket=Trade.ResultOrder();

      if(!ok)
        {
         uint rc=Trade.ResultRetcode();
         if(rc==TRADE_RETCODE_INVALID_STOPS || rc==TRADE_RETCODE_INVALID_PRICE)
           {
            Print("[ZERO] Market retry WITHOUT SL/TP (rc=",rc,")");
            ok=PlaceMarketWithFallback(s.is_buy,lots,0.0,0.0,ordComment);
            ticket=Trade.ResultOrder();
            placed_without_stops=ok;
           }
        }
      if(!ok)
        {
         PrintFormat("[ZERO] Market order failed: rc=%u (%s) err=%d", Trade.ResultRetcode(), Trade.ResultRetcodeDescription(), GetLastError());
         return;
        }

      // get actual fill
      ulong pos_ticket=0;
      double pos_open=0.0;
      datetime newest=0;
      const int MAX_TRIES=12, SLEEP_MS=120;
      for(int t=0;t<MAX_TRIES && pos_ticket==0; ++t)
        {
         int ptotal=PositionsTotal();
         for(int i=0;i<ptotal;i++)
           {
            ulong pt=PositionGetTicket(i);
            if(pt==0 || !PositionSelectByTicket(pt))
               continue;
            if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
               continue;
            if(!MagicIsOurs((long)PositionGetInteger(POSITION_MAGIC)))
               continue;
            ENUM_POSITION_TYPE ty=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if((s.is_buy && ty!=POSITION_TYPE_BUY) || (!s.is_buy && ty!=POSITION_TYPE_SELL))
               continue;
            datetime ct=(datetime)PositionGetInteger(POSITION_TIME);
            if(ct>=newest)
              {
               newest=ct;
               pos_ticket=pt;
               pos_open=PositionGetDouble(POSITION_PRICE_OPEN);
              }
           }
         if(pos_ticket==0)
            Sleep(SLEEP_MS);
        }
      placed_price = (pos_ticket?pos_open:ref_now);

      // desired SL/TP calculated vs current ref, then re-by-R from actual fill for TP
      double sl_des=sl, tp_des=0.0;
      double ref2 = s.is_buy?SymbolInfoDouble(_Symbol,SYMBOL_ASK):SymbolInfoDouble(_Symbol,SYMBOL_BID);
      FixStopsToLevels(ref2, s.is_buy, sl_des, tp_des);
      if(Inp_ExitMode==Exit_FixedTPs)
        {
         double R2=MathAbs(placed_price-sl_des);
         if(Inp_OrderTP==Use_TP1 && Inp_RR_TP1>0.0)
            tp_des=s.is_buy?(placed_price+R2*Inp_RR_TP1):(placed_price-R2*Inp_RR_TP1);
         else
            if(Inp_OrderTP==Use_TP2 && Inp_RR_TP2>0.0)
               tp_des=s.is_buy?(placed_price+R2*Inp_RR_TP2):(placed_price-R2*Inp_RR_TP2);
         if(tp_des>0.0)
            FixStopsToLevels(ref2, s.is_buy, sl_des, tp_des);
        }
      double tp_to_set=(Inp_ExitMode==Exit_FixedTPs?tp_des:0.0);
      BumpForFreezeLevel(s.is_buy, sl_des, tp_to_set);

      // >>> HARD GUARANTEE: attach stops or close <<<
      if(placed_without_stops)
        {
         Print("[ZERO_GUARD] Market placed without stops — enforcing SL/TP immediately.");
        }
      EnsureSLTPOrClose(s.is_buy, sl_des, tp_to_set, pos_ticket);

      // journal OPEN
      PositionSelect(_Symbol); // ensure selected before reading
      // PrintFormat("[ZERO_TRADE]|PH=OPEN|MODE=MKT|TIME=%s|SYM=%s|SIDE=%s|LOT=%.3f|FILL=%.*f|SL=%.*f|TP=%.*f|MAGIC=%I64d|ORDER=%I64u|CONF=%s|TF=%s|FT=%c|ZONE=[%s:%.5f..%.5f]",
      //             TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES|TIME_SECONDS),
      //             _Symbol, (s.is_buy?"BUY":"SELL"), lots,
      //             DigitsSym(), placed_price,
      //             DigitsSym(), PositionGetDouble(POSITION_SL),
      //             DigitsSym(), PositionGetDouble(POSITION_TP),
      //             (long)Inp_Magic, ticket, conf, tf, ft,
      //             (s.is_buy?"B":"S"), s.z_bot, s.z_top);

      // Display trade info label on chart at entry
      // Find the matching FVGZone for this signal (by tf, t_left, upper/lower)
      
             
               long   fvg_id   = -1;
string fvg_name = "";
double fvg_width = 0.0, fvg_disp = 0.0;

int zi = FindZoneIndexBySpec(s.htf, s.is_buy, s.z_t1, s.z_top, s.z_bot);
if(zi >= 0)
{
   const FVGZone z = g_zones[zi];  // <-- copy, not reference
   fvg_id    = z.id;
   fvg_name  = z.name;
   fvg_width = MathAbs(z.upper - z.lower) / _Point;
   double fvg_disp = s.z_disp;          // use the SAME value used to pass the filter
if(fvg_disp <= 0.0) {                // fallback only if missing (older signals, etc.)
   double d;
   if(HTF_DisplacementFactor(s.htf, s.z_t1, d))
      fvg_disp = d;
}

}
else
{
   // Fallbacks if there's no g_zones entry (e.g., not yet scanned)
   fvg_id    = (long)s.z_t1; // stable pseudo-ID
   fvg_name  = BuildOverlayFVGName(s.htf, s.is_buy, s.z_t1);
   fvg_width = MathAbs(s.z_top - s.z_bot) / _Point;
   double d; if(HTF_DisplacementFactor(s.htf, s.z_t1, d)) fvg_disp = d;
}

      // string tradeLabelName = StringFormat("TRADE_INFO_%s_%I64u", _Symbol, ticket);
      // // Remove any previous multi-line trade labels
      // for(int i=0;i<10;i++) {
      //    string tradeLine = tradeLabelName + StringFormat("_%d", i);
      //    if(ObjectFind(0, tradeLine) >= 0) ObjectDelete(0, tradeLine);
      // }
      // // Try to get the score from the candidate if available, fallback to 0.0
      // double score = 0.0;
      // if(zi >= 0 && zi < g_zone_count) {
      //    // Try to find the candidate for this zone and get its score
      //    // If you have a candidate array, use it; otherwise, fallback to s.info parsing or 0.0
      //    // For now, try to get from s.info if present
      //    int p = StringFind(s.info, "Score:");
      //    if(p >= 0) {
      //       string sub = StringSubstr(s.info, p+6);
      //       int end = StringFind(sub, " ");
      //       if(end > 0) sub = StringSubstr(sub, 0, end);
      //       score = StringToDouble(sub);
      //    }
      // }
      // string tradeLabelText = StringFormat(
      //    "Name: %s\nWidth: %dpt | Disp: %.2f\nConfirm: %s",
      //      fvg_name, (int)MathRound(fvg_width), fvg_disp, s.confirm);
      // string lines[];
      // int nLines = StringSplit(tradeLabelText, '\n', lines);
      // double baseY = placed_price + (s.is_buy ? 2*_Point : -2*_Point);
      // for(int i=0; i<nLines; ++i) {
      //    string tradeLine = tradeLabelName + StringFormat("_%d", i);
      //    double yLine = baseY + (i - nLines/2.0) * Inp_LabelLineStepPoints * _Point;
      //    if(ObjectFind(0, tradeLine) < 0)
      //       ObjectCreate(0, tradeLine, OBJ_TEXT, 0, TimeCurrent(), yLine);
      //    else
      //       ObjectMove(0, tradeLine, 0, TimeCurrent(), yLine);
      //    ObjectSetString(0, tradeLine, OBJPROP_TEXT, lines[i]);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_COLOR, (long)Inp_Color_Foreground);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_FONTSIZE, Inp_FVGInfoFontSize);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_BACK, false);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_HIDDEN, false);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_SELECTABLE, false);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_ANCHOR, ANCHOR_CENTER);
      //    ObjectSetInteger(0, tradeLine, OBJPROP_ZORDER, 3000);
   
       
       if(Inp_ShowTradeExecLabels) DrawTradeExecLabel(s, ticket, placed_price);
 
      ChartRedraw();
     }
   else
     {
      // ----- pending -----
      datetime exp=(Inp_PendingExpiryMin>0)?(TimeCurrent()+Inp_PendingExpiryMin*60):0;

      ok=PlacePendingWithFallback(s.is_buy,lots,entry_px,sl,tp,exp,ordComment);
      ticket=Trade.ResultOrder();

      if(!ok)
        {
         uint rc=Trade.ResultRetcode();
         if(rc==TRADE_RETCODE_INVALID_STOPS || rc==TRADE_RETCODE_INVALID_PRICE)
           {
            Print("[ZERO] Pending retry WITHOUT SL/TP (rc=",rc,")");
            ok=PlacePendingWithFallback(s.is_buy,lots,entry_px,0.0,0.0,exp,ordComment);
            ticket=Trade.ResultOrder();
            placed_without_stops=ok;
           }
        }
      if(!ok)
        {
         PrintFormat("[ZERO] Pending failed: rc=%u (%s) err=%d", Trade.ResultRetcode(), Trade.ResultRetcodeDescription(), GetLastError());
         return;
        }

      // If we had to place pending without stops, try to attach to the ORDER now
      const int MAX_TRIES=12, SLEEP_MS=120;
      for(int t=0;t<MAX_TRIES;++t)
        {
         if(OrderSelect(ticket))
           {
            double px   = OrderGetDouble(ORDER_PRICE_OPEN);
            double curSL= OrderGetDouble(ORDER_SL);
            double curTP= OrderGetDouble(ORDER_TP);
            datetime oexp=(datetime)OrderGetInteger(ORDER_TIME_EXPIRATION);
            ENUM_ORDER_TYPE_TIME ttype=(oexp==0?ORDER_TIME_GTC:ORDER_TIME_SPECIFIED);

            double ref2 = s.is_buy?SymbolInfoDouble(_Symbol,SYMBOL_ASK):SymbolInfoDouble(_Symbol,SYMBOL_BID);
            double sl_des=s.sl, tp_des=0.0;
            FixStopsToLevels(ref2, s.is_buy, sl_des, tp_des);

            if(Inp_ExitMode==Exit_FixedTPs)
              {
               double R3=MathAbs(px-sl_des);
               if(Inp_OrderTP==Use_TP1 && Inp_RR_TP1>0.0)
                  tp_des=s.is_buy?(px+R3*Inp_RR_TP1):(px-R3*Inp_RR_TP1);
               else
                  if(Inp_OrderTP==Use_TP2 && Inp_RR_TP2>0.0)
                     tp_des=s.is_buy?(px+R3*Inp_RR_TP2):(px-R3*Inp_RR_TP2);
               if(tp_des>0.0)
                  FixStopsToLevels(ref2, s.is_buy, sl_des, tp_des);
              }

            if(placed_without_stops || NeedUpdateSLTP(curSL,sl_des,_Point*2.0) || NeedUpdateSLTP(curTP,tp_des,_Point*2.0))
              {
               if(!Trade.OrderModify(ticket, px, 0.0, ToTick(sl_des), ttype, oexp,
                                     (Inp_ExitMode==Exit_FixedTPs ? ToTick(tp_des) : 0.0)))
                 {
                  uint rc=Trade.ResultRetcode();
                  if(rc==TRADE_RETCODE_INVALID_STOPS || rc==TRADE_RETCODE_INVALID_PRICE)
                    {
                     if(s.is_buy)
                       {
                        sl_des -= 2*_Point;
                        if(tp_des>0.0)
                           tp_des += 2*_Point;
                       }
                     else
                       {
                        sl_des += 2*_Point;
                        if(tp_des>0.0)
                           tp_des -= 2*_Point;
                       }
                     sl_des = ToTick(sl_des);
                     if(tp_des>0.0)
                        tp_des = ToTick(tp_des);
                     Trade.OrderModify(ticket, px, 0.0, sl_des, ttype, oexp,
                                       (Inp_ExitMode==Exit_FixedTPs ? tp_des : 0.0));
                    }
                 }
              }
            break;
           }
         else
           {
            // order may have filled before we attached SL; OnTradeTransaction will enforce via EnsureSLTPOrClose()
            break;
           }
         Sleep(SLEEP_MS);
        }

      // journal PENDING (read from the order explicitly)
      if(OrderSelect(ticket))
        {
         if (Inp_ShowTradeExecLabels)
         {
            DrawTradeExecLabel(s, ticket, entry_px);
            ChartRedraw();
         }
      
         
         // PrintFormat("[ZERO_TRADE]|PH=PEND|MODE=PEND|TIME=%s|SYM=%s|SIDE=%s|LOT=%.3f|PRICE=%.*f|SL=%.*f|TP=%.*f|EXP=%s|MAGIC=%I64d|ORDER=%I64u|CONF=%s|TF=%s|FT=%c|ZONE=[%s:%.5f..%.5f]",
         //             TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES|TIME_SECONDS),
         //             _Symbol, (s.is_buy?"BUY":"SELL"), lots,
         //             DigitsSym(), entry_px,
         //             DigitsSym(), OrderGetDouble(ORDER_SL),
         //             DigitsSym(), OrderGetDouble(ORDER_TP),
         //             (Inp_PendingExpiryMin>0 ? TimeToString(TimeCurrent()+Inp_PendingExpiryMin*60, TIME_MINUTES|TIME_SECONDS) : "GTC"),
         //             (long)Inp_Magic, ticket, conf, tf, ft,
         //             (s.is_buy?"B":"S"), s.z_bot, s.z_top);

         // (CSV event removed)
        }
     }

   g_signals[idx].traded=true;
   g_signals[idx].ticket=ticket;
   MarkZoneTraded(s.htf, s.is_buy, s.z_t1, s.z_top, s.z_bot);

   PrintFormat("[ZERO] %s placed | lots=%.3f | mode=%s | comment='%s'",
               (s.is_buy? "BUY":"SELL"), lots, modeStr, ordComment);

// restore default magic for subsequent operations
   if(Inp_UsePackedMagic)
      Trade.SetExpertMagicNumber((ulong)Inp_Magic);
  }

  void DrawTradeExecLabel(const Signal &s, ulong ticket, double price_now)
{
   if(!Inp_ShowTradeExecLabels) return;

   // figure out FVG info
   int zi = FindZoneIndexBySpec(s.htf, s.is_buy, s.z_t1, s.z_top, s.z_bot);
   string fvg_name  = (zi>=0 ? g_zones[zi].name : BuildOverlayFVGName(s.htf, s.is_buy, s.z_t1));
   double fvg_width = (zi>=0 ? MathAbs(g_zones[zi].upper - g_zones[zi].lower)
                             : MathAbs(s.z_top - s.z_bot)) / _Point;
   double fvg_disp  = s.z_disp;
   if(fvg_disp<=0.0){ double d; if(HTF_DisplacementFactor(s.htf, s.z_t1, d)) fvg_disp=d; }

   string text = StringFormat("Name: %s\nWidth: %dpt | Disp: %.2f\nConfirm: %s",
                              fvg_name, (int)MathRound(fvg_width), fvg_disp, s.confirm);

   string lines[]; int n = StringSplit(text, '\n', lines);
   string base = StringFormat("TRADE_INFO_%s_%I64u", _Symbol, ticket);

   // clear old
   for(int i=0;i<10;i++){ string nm=base+StringFormat("_%d",i);
      if(ObjectFind(0,nm)>=0) ObjectDelete(0,nm); }

   double baseY = price_now + (s.is_buy ? 2*_Point : -2*_Point);
   for(int i=0;i<n;i++)
   {
      string nm = base + StringFormat("_%d", i);
      double yi = baseY + (i - n/2.0) * Inp_LabelLineStepPoints * _Point;

      if(ObjectFind(0,nm)<0) ObjectCreate(0,nm,OBJ_TEXT,0,TimeCurrent(),yi);
      else                   ObjectMove  (0,nm,0,TimeCurrent(),yi);

      ObjectSetString (0,nm,OBJPROP_TEXT, lines[i]);
      ObjectSetInteger(0,nm,OBJPROP_COLOR, (long)Inp_Color_Foreground);
      ObjectSetInteger(0,nm,OBJPROP_FONTSIZE, Inp_FVGInfoFontSize);
      ObjectSetInteger(0,nm,OBJPROP_ANCHOR, ANCHOR_CENTER);
      ObjectSetInteger(0,nm,OBJPROP_BACK, false);
      ObjectSetInteger(0,nm,OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0,nm,OBJPROP_ZORDER, 3000);
   }
   ChartRedraw();
}


// Find our signal by order ticket (stored when placing orders)
int FindSignalByOrderTicket(ulong ord_ticket)
  {
   for(int i=ArraySize(g_signals)-1; i>=0; --i)
      if(g_signals[i].traded && g_signals[i].ticket==ord_ticket)
         return i;
   return -1;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ManageOpenPositions_BE_Trail()
  {
   if(Inp_ExitMode!=Exit_BE_Trail)
      return;

   PM_EnsureForPosition();

   const double spread = GetSpreadPrice();

   for(int i=0;i<PositionsTotal();++i)
     {
      ulong pt = PositionGetTicket(i);
      if(pt==0 || !PositionSelectByTicket(pt))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if(!MagicIsOurs((long)PositionGetInteger(POSITION_MAGIC)))
         continue;

      int stIx = PM_Find(pt);
      if(stIx<0)
         continue;

      PMState st = g_pmStates[stIx];

      bool   is_buy = ((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY);
      double entry  = st.entry;
      double sl     = PositionGetDouble(POSITION_SL);

      // current market refs
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double last= is_buy ? bid : ask;                    // use this as "ref" for stop-levels

      if(!st.movedBE)
        {
         double curSLnow = PositionGetDouble(POSITION_SL);
         // If we seeded initialSL earlier (no SL at place), adopt the first real SL
         if(curSLnow > 0.0)
           {
            if(MathAbs(curSLnow - st.initialSL) > _Point*0.5)
              {
               st.initialSL = curSLnow;
               g_pmStates[stIx] = st;
              }
           }
        }

      double R0 = MathAbs(entry - st.initialSL);
      if(R0 < _Point*2.0)
         continue;

      double profR = is_buy ? (last - entry)/R0 : (entry - last)/R0;

      // ensure no TP in BE/trailing mode
      double curTPnow = PositionGetDouble(POSITION_TP);
      if(curTPnow > 0.0)
         Trade.PositionModify(pt, sl, 0.0);

      // BE at +1R
      if(!st.movedBE && profR >= Inp_BE_Trig_R)
        {
         double newSL = is_buy ? (entry + spread) : (entry - spread);
         double tp_dummy=0.0;
         FixStopsToLevels(last, is_buy, newSL, tp_dummy); // <— guard vs current price
         BumpForFreezeLevel(is_buy, newSL, tp_dummy);

         bool improves = is_buy ? (newSL > sl) : (newSL < sl);
         if(improves)
           {
            if(Trade.PositionModify(pt, ToTick(newSL), 0.0))
              {
               st.movedBE = true;
               g_pmStates[stIx] = st;
               if(Inp_LogToJournal && !Inp_LogOnlyTrades)
                 {

                  PrintFormat("[ZERO] Move to BE+spread on %I64u at %.5f (%.2fR)", pt, newSL, profR);
                 }
               // (CSV event removed)
              }
           }
         else
           {
            // Only mark BE as done if SL is already at/beyond BE; else retry next ticks
            bool alreadyBE = is_buy ? (sl >= entry) : (sl <= entry);
            if(alreadyBE)
              {
               st.movedBE = true;
               g_pmStates[stIx] = st;
              }
           }
        }

      // Arm trailing at +2R
      if(!st.trailArmed && profR >= Inp_Trail_Trig_R)
        {
         st.trailArmed = true;
         g_pmStates[stIx] = st;
        }

      // Trailing by last swing (with +1R floor)
      if(st.trailArmed)
        {
         double swing;
         int kTrail = MathMax(1, Inp_Trail_SwingK - 1);
         bool gotSwing = LastLTF_Swing(is_buy, kTrail, swing);

         double pad = spread * Inp_SL_Pad_SpreadMult;
         double wantSL_fromSwing = sl;
         if(gotSwing)
            wantSL_fromSwing = is_buy ? (swing - pad) : (swing + pad);

         double floor1R   = is_buy ? (entry + R0) : (entry - R0);
         double wantSL_floor = is_buy ? (floor1R - pad) : (floor1R + pad);

         double wantSL = wantSL_fromSwing;
         bool improvesSwing = is_buy ? (wantSL_fromSwing > sl) : (wantSL_fromSwing < sl);
         bool improvesFloor = is_buy ? (wantSL_floor  > sl) : (wantSL_floor  < sl);
         if(!improvesSwing && profR >= Inp_Trail_Trig_R && improvesFloor)
            wantSL = wantSL_floor;

         bool improves = is_buy ? (wantSL > sl) : (wantSL < sl);
         if(improves)
           {
            double tp_dummy=0.0;
            FixStopsToLevels(last, is_buy, wantSL, tp_dummy); // <— guard vs current price
            BumpForFreezeLevel(is_buy, wantSL, tp_dummy);

            // small nudge if broker says invalid (common on tight symbols)
            double trySL = ToTick(wantSL);
            if((is_buy && trySL < last) || (!is_buy && trySL > last))
              {
               if(!Trade.PositionModify(pt, trySL, 0.0))
                 {
                  uint rc = Trade.ResultRetcode();
                  if(rc==TRADE_RETCODE_INVALID_STOPS || rc==TRADE_RETCODE_INVALID_PRICE)
                    {
                     if(is_buy)
                        trySL -= 2*_Point;
                     else
                        trySL += 2*_Point;
                     Trade.PositionModify(pt, ToTick(trySL), 0.0);
                    }
                 }
               else
                 {
                  if(Inp_LogToJournal && !Inp_LogOnlyTrades)
                     PrintFormat("[ZERO] Trailing SL -> %.5f on %I64u (%.2fR)", trySL, pt, profR);
                  // (CSV event removed)
                 }
              }
           }
        }
     }
  }

//==================== HTF OVERLAY ====================//
void DrawFVGZone(string name, bool is_buy, int shift, double top, double bot, datetime t1, datetime t2, color clr)
  {
   if(ObjectFind(0, name)>=0)
      ObjectDelete(0, name);
   ObjectCreate(0, name, OBJ_RECTANGLE, 0, t1, top, t2, bot);
   ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, name, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, name, OBJPROP_WIDTH, 1);
   ObjectSetInteger(0, name, OBJPROP_BACK, true);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool FindFVG(bool is_buy, int &out_shift, double &top, double &bot, double &mid, ENUM_TIMEFRAMES tf)
  {
   int need = MathMax(600, Inp_LookbackBars);
   MqlRates r[];
   int bars = CopyRates(_Symbol, tf, 0, need, r);
   if(bars<5)
      return false;
   ArraySetAsSeries(r,true);

   for(int s=1; s<=bars-3; ++s)
     {
      double low_r  = r[s].low;
      double high_r = r[s].high;
      double low_l  = r[s+2].low;
      double high_l = r[s+2].high;

      if(is_buy)
        {
         if(low_r > high_l)
           {
            double lower = high_l, upper = low_r;
            if(!PassesSizeFilter(tf, lower, upper))
               continue;
            top = upper;
            bot = lower;
            mid = (top+bot)/2.0;
            out_shift = s;
            return true;
           }
        }
      else
        {
         if(high_r < low_l)
           {
            double lower = high_r, upper = low_l;
            if(!PassesSizeFilter(tf, lower, upper))
               continue;
            top = upper;
            bot = lower;
            mid = (top+bot)/2.0;
            out_shift = s;
            return true;
           }
        }
     }
   return false;
  }

// Enforce a single visible HTF box per TF/side, respect mitigation + retirement
void EnsureSingleHTFBox(const string baseName,
                        const color  clr,
                        const ENUM_TIMEFRAMES tf,
                        const datetime t1_in,
                        const double top_in,
                        const double bot_in,
                        const bool   is_buy)
  {
   const string lineName = baseName + "_LINE";
   const datetime now = TimeCurrent();

// 1) If mitigated -> remember retired and delete visuals
   if(IsMitigated_HTF(top_in, bot_in, is_buy, tf))
     {
      RememberZone(tf, is_buy, t1_in, top_in, bot_in, true);
      ObjectDelete(0, baseName);
      ObjectDelete(0, lineName);
      return;
     }

// 2) If previously retired, don't resurrect it
   if(IsRetired(tf, is_buy, t1_in, top_in, bot_in))
     {
      ObjectDelete(0, baseName);
      ObjectDelete(0, lineName);
      return;
     }

// 3) Create / update the active rectangle
   if(ObjectFind(0, baseName)<0)
      ObjectCreate(0, baseName, OBJ_RECTANGLE, 0, t1_in, top_in, now, bot_in);
   else
      ObjectMove(0, baseName, 1, now, bot_in);

   ObjectSetInteger(0, baseName, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, baseName, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, baseName, OBJPROP_WIDTH, 1);
  ObjectSetInteger(0, baseName, OBJPROP_BACK, true);

// Info label for HTF overlay box (gap width & momentum) centered
   if(Inp_ShowFVGInfo)
   {
      string infoName = baseName + "_INFO";
      int zi = FindZoneIndexBySpec(tf, is_buy, t1_in, top_in, bot_in);
      long   id_show   = (zi >= 0 ? g_zones[zi].id   : (long)t1_in); // fallback: timestamp
      string name_show = (zi >= 0 ? g_zones[zi].name : BuildOverlayFVGName(tf, is_buy, t1_in));
      double w    = MathAbs(top_in - bot_in);
      double wPts = w/_Point;
      double atr  = ATR(tf, Inp_ATR_Period);
      double wATR = (atr>0.0 ? (w/atr) : 0.0);
      double disp = 0.0;
      bool gotDisp = HTF_DisplacementFactor(tf, t1_in, disp);
      string txt = StringFormat("ID:%I64d\n%s\nW:%dpt | W/ATR:%.2f | Disp:%.2f",
                                             id_show, name_show, (int)MathRound(wPts), wATR, (gotDisp?disp:0.0));
      // Remove any previous multi-line info labels
      for(int i=0;i<10;i++) {
         string infoLine = infoName + StringFormat("_%d", i);
         if(ObjectFind(0, infoLine) >= 0) ObjectDelete(0, infoLine);
      }
      // Split txt into lines
      string lines[];
      int nLines = StringSplit(txt, '\n', lines);
      const double y = (top_in + bot_in)*0.5;
      const datetime now = TimeCurrent();
      datetime tx = (datetime)((long)t1_in + ((long)now - (long)t1_in)/2);
      for(int i=0; i<nLines; ++i) {
         string infoLine = infoName + StringFormat("_%d", i);
         double yLine = y + (i - nLines/2.0) * Inp_LabelLineStepPoints * _Point;
         if(ObjectFind(0, infoLine) < 0)
            ObjectCreate(0, infoLine, OBJ_TEXT, 0, tx, yLine);
         else
            ObjectMove(0, infoLine, 0, tx, yLine);
         ObjectSetString (0, infoLine, OBJPROP_TEXT, lines[i]);
         ObjectSetInteger(0, infoLine, OBJPROP_COLOR, (long)Inp_Color_Foreground);
         ObjectSetInteger(0, infoLine, OBJPROP_FONTSIZE, Inp_FVGInfoFontSize);
         ObjectSetInteger(0, infoLine, OBJPROP_BACK, false);
         ObjectSetInteger(0, infoLine, OBJPROP_SELECTABLE, false);
         ObjectSetInteger(0, infoLine, OBJPROP_ZORDER, 1200);
         ObjectSetInteger(0, infoLine, OBJPROP_ANCHOR, ANCHOR_CENTER);
      }
   }
   else {
      string infoName = baseName + "_INFO";
      for(int i=0;i<10;i++) {
         string infoLine = infoName + StringFormat("_%d", i);
         if(ObjectFind(0, infoLine) >= 0) ObjectDelete(0, infoLine);
      }
   }

  ChartRedraw();

// 4) Midline (optional)
   if(Inp_DrawHTF_Midline)
     {
      const double midPrice=(top_in+bot_in)*0.5;
      if(ObjectFind(0, lineName)<0)
         ObjectCreate(0, lineName, OBJ_TREND, 0, t1_in, midPrice, now, midPrice);
      else
         ObjectMove(0, lineName, 1, now, midPrice);
      ObjectSetInteger(0, lineName, OBJPROP_COLOR, clr);
      ObjectSetInteger(0, lineName, OBJPROP_STYLE, STYLE_DASH);
      ObjectSetInteger(0, lineName, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, lineName, OBJPROP_RAY_RIGHT, false);
     }

// 5) Remember as the current non-retired zone
   RememberZone(tf, is_buy, t1_in, top_in, bot_in, false);

  // 6) Remove any other HTF_* rectangles of the same TF/side (enforce single)
  const int total = ObjectsTotal(0, -1, -1);
  for(int i=total-1; i>=0; --i)
    {
     string nm = ObjectName(0,i);
     if(StringFind(nm, "HTF_")!=0)
        continue;
     if(nm==baseName || nm==lineName)
         continue;

     // Keep info labels (text) intact
     if(StringFind(nm, "_INFO")>=0)
        continue;

     // Only remove other rectangles, not lines/text
     long otype = ObjectGetInteger(0, nm, OBJPROP_TYPE);
     if(otype != OBJ_RECTANGLE)
        continue;

     const bool matchTF   = ((StringFind(nm,"HTF_H1_")>=0 && tf==PERIOD_H1) ||
                              (StringFind(nm,"HTF_H4_")>=0 && tf==PERIOD_H4) ||
                              (StringFind(nm,"HTF_M15_")>=0 && tf==PERIOD_M15));
     const bool matchSide = (is_buy && StringFind(nm,"_BUY_") >=0) ||
                             (!is_buy && StringFind(nm,"_SELL_")>=0);

     if(matchTF && matchSide)
        ObjectDelete(0,nm);
    }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void DrawHTFFVG_Extended(bool is_buy)
  {
   int shift;
   double top, bot, mid;
   const datetime now = TimeCurrent();

// optional: time-based cleanup of any HTF_* rectangles
   if(Inp_CleanFVG_AfterHours>0)
     {
      int total = ObjectsTotal(0, -1, -1);
      for(int i=total-1; i>=0; --i)
        {
         string name = ObjectName(0,i);
         if(StringFind(name, "HTF_")!=0)
            continue;
         datetime t_obj = (datetime)ObjectGetInteger(0, name, OBJPROP_TIME, 0);
         if((now - t_obj) > Inp_CleanFVG_AfterHours*3600)
           {
            ObjectDelete(0,name);
            string lineName = name+"_LINE";
            string infoName = name+"_INFO";
            if(ObjectFind(0,lineName)>=0)
               ObjectDelete(0,lineName);
            if(ObjectFind(0,infoName)>=0)
               ObjectDelete(0,infoName);
           }
        }
     }

// -------- H1 --------
   if(Inp_HTFMode==HTF_H1_M5 || Inp_HTFMode==HTF_BOTH || Inp_HTFMode==HTF_ANY)
     {
      if(FindFVG(is_buy, shift, top, bot, mid, PERIOD_H1))
        {
         datetime t1 = iTime(_Symbol, PERIOD_H1, shift+2);
         if(Inp_CleanFVG_AfterHours>0 && (now - t1) > Inp_CleanFVG_AfterHours*3600)
            RememberZone(PERIOD_H1, is_buy, t1, top, bot, true);
         else
           {
            string side    = is_buy ? "BUY" : "SELL";
            color  h1Color = is_buy ? Inp_H1_BuyColor : Inp_H1_SellColor;
            string base    = StringFormat("HTF_H1_FVG_%s_%s", side, TimeToString(t1, TIME_DATE|TIME_MINUTES));
            EnsureSingleHTFBox(base, h1Color, PERIOD_H1, t1, top, bot, is_buy);
           }
        }
     }

// -------- H4 --------
   if(Inp_HTFMode==HTF_H4_M15 || Inp_HTFMode==HTF_BOTH || Inp_HTFMode==HTF_ANY)
     {
      if(FindFVG(is_buy, shift, top, bot, mid, PERIOD_H4))
        {
         datetime t1 = iTime(_Symbol, PERIOD_H4, shift+2);
         if(Inp_CleanFVG_AfterHours>0 && (now - t1) > Inp_CleanFVG_AfterHours*3600)
            RememberZone(PERIOD_H4, is_buy, t1, top, bot, true);
         else
           {
            string side    = is_buy ? "BUY" : "SELL";
            color  h4Color = is_buy ? Inp_H4_BuyColor : Inp_H4_SellColor;
            string base    = StringFormat("HTF_H4_FVG_%s_%s", side, TimeToString(t1, TIME_DATE|TIME_MINUTES));
            EnsureSingleHTFBox(base, h4Color, PERIOD_H4, t1, top, bot, is_buy);
           }
        }
     }

// -------- M15 (scalper mode) --------
   if(Inp_HTFMode==HTF_M15_M1)
     {
      if(FindFVG(is_buy, shift, top, bot, mid, PERIOD_M15))
        {
         datetime t1 = iTime(_Symbol, PERIOD_M15, shift+2);
         if(Inp_CleanFVG_AfterHours>0 && (now - t1) > Inp_CleanFVG_AfterHours*3600)
            RememberZone(PERIOD_M15, is_buy, t1, top, bot, true);
         else
           {
            string side    = is_buy ? "BUY" : "SELL";
            // reuse H1 colors for M15 to avoid extra inputs
            color  m15Color = is_buy ? Inp_H1_BuyColor : Inp_H1_SellColor;
            string base     = StringFormat("HTF_M15_FVG_%s_%s", side, TimeToString(t1, TIME_DATE|TIME_MINUTES));
            EnsureSingleHTFBox(base, m15Color, PERIOD_M15, t1, top, bot, is_buy);
           }
        }
     }
  }


// --- Cleanup HTF boxes if mitigated (name-based)
void CleanupMitigatedFVGs()
  {
   int total = ObjectsTotal(0, -1, -1);
   for(int i = total - 1; i >= 0; --i)
     {
      string name = ObjectName(0, i);
      if(StringFind(name, "HTF_") != 0 || StringFind(name, "_LINE") >= 0)
         continue;

      double p1 = ObjectGetDouble(0, name, OBJPROP_PRICE, 0);
      double p2 = ObjectGetDouble(0, name, OBJPROP_PRICE, 1);
      double top = MathMax(p1, p2), bot = MathMin(p1, p2);

      bool isH1   = (StringFind(name, "HTF_H1")==0);
      bool isH4   = (StringFind(name, "HTF_H4")==0);
      bool isM15  = (StringFind(name, "HTF_M15")==0);
      bool is_buy = (StringFind(name, "_BUY_") > 0);
      ENUM_TIMEFRAMES tf = isH1 ? PERIOD_H1 : (isH4 ? PERIOD_H4 : (isM15 ? PERIOD_M15 : PERIOD_CURRENT));

      if(IsMitigated_HTF(top, bot, is_buy, tf))
        {
         datetime t1 = (datetime)ObjectGetInteger(0, name, OBJPROP_TIME, 0);
         RememberZone(tf, is_buy, t1, top, bot, true);
         string lineName = name + "_LINE";
         string infoName = name + "_INFO";
         ObjectDelete(0, name);
         ObjectDelete(0, lineName);
         if(ObjectFind(0, infoName)>=0)
            ObjectDelete(0, infoName);
        }
     }
  }

//==================== GENERIC MITIGATION ====================//
double ThresholdPrice(const FVGZone &z)
  {
   if(Inp_MitigationMode==MitigateOnTouch)
      return z.bullish? z.upper : z.lower;
   if(Inp_MitigationMode==MitigateAt50)
      return Mid(z.lower,z.upper);
   return z.bullish? z.lower : z.upper;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool MitigatedNow(const FVGZone &z, double bid, double ask)
  {
   double th = ThresholdPrice(z);
   double last = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   if(z.bullish)
      return (bid<=th || last<=th);
   return (ask>=th || last>=th);
  }

void RefreshGraphics() { for(int i=0;i<g_zone_count;i++) if(g_zones[i].active) DrawOrUpdate(g_zones[i]); }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CheckMitigations()
  {
   double bid=SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask=SymbolInfoDouble(_Symbol, SYMBOL_ASK);
  for(int i=0;i<g_zone_count;i++)
    {
      if(!g_zones[i].active)
         continue;
      if(MitigatedNow(g_zones[i],bid,ask))
        {
          g_zones[i].active=false;
          if(Inp_AutoRemoveOnMit)
            {
              DeleteZoneGraphics(g_zones[i]);
            }
          else
            {
              if(ObjectFind(0, g_zones[i].name)!=-1)
                {
                  uint fill = ColorWithAlpha(g_zones[i].bullish?Inp_BullColor:Inp_BearColor, Inp_FillAlpha/3);
                  ObjectSetInteger(0, g_zones[i].name, OBJPROP_BGCOLOR, fill);
                  ObjectSetInteger(0, g_zones[i].name, OBJPROP_COLOR, clrSilver);
                }
              if(ObjectFind(0, g_zones[i].name50)!=-1)
                 ObjectSetInteger(0, g_zones[i].name50, OBJPROP_COLOR, clrSilver);
              // Zone became invalid: remove the info label even if we keep the box
              string infoName = g_zones[i].name + "_INFO";
              if(ObjectFind(0, infoName)>=0)
                 ObjectDelete(0, infoName);
            }
        }
    }
  }

//==================== INIT/DEINIT/EVENTS ====================//
void ParseTFInputs()
  {
   g_tf_count=0;
   ArrayInitialize(g_last_right_time, 0);
// Drive scanning strictly from Inp_HTFMode (Inp_TFs deprecated for scanning)
   switch(Inp_HTFMode)
     {
      case HTF_H1_M5:
         g_tfs[g_tf_count++] = PERIOD_H1;
         break;
      case HTF_H4_M15:
         g_tfs[g_tf_count++] = PERIOD_H4;
         break;
      case HTF_BOTH:
      case HTF_ANY:
         g_tfs[g_tf_count++] = PERIOD_H1;
         if(g_tf_count<MAX_TF)
            g_tfs[g_tf_count++] = PERIOD_H4;
         break;
      case HTF_M15_M1:
         g_tfs[g_tf_count++] = PERIOD_M15;
         break;
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double ToTick(double price)
  {
   double ts = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(ts<=0)
      ts = _Point;
// round to nearest tick and normalize to symbol digits
   return NormalizeDouble(MathRound(price/ts)*ts, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));
  }
 

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void FixStopsToLevels(double ref,bool buy,double &sl,double &tp)
  {
   int stl=(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);
   double lim=stl*_Point;
   if(lim<=0)
      return;
   if(buy)
     {
      if(sl>0 && ref-sl<lim)
         sl=ref-lim;
      if(tp>0 && tp-ref<lim)
         tp=ref+lim;
     }
   else
     {
      if(sl>0 && sl-ref<lim)
         sl=ref+lim;
      if(tp>0 && ref-tp<lim)
         tp=ref-lim;
     }
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void BumpForFreezeLevel(bool buy,double &sl,double &tp)
  {
   int fr=(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_FREEZE_LEVEL);
   double lim=fr*_Point;
   if(lim<=0)
      return;
   double px=SymbolInfoDouble(_Symbol, buy?SYMBOL_BID:SYMBOL_ASK);
   if(buy)
     {
      if(sl>0 && px-sl<lim)
         sl=px-lim;
      if(tp>0 && tp-px<lim)
         tp=px+lim;
     }
   else
     {
      if(sl>0 && sl-px<lim)
         sl=px+lim;
      if(tp>0 && px-tp<lim)
         tp=px-lim;
     }
  }


//===============LOG TRADES & JOURNAL TO CSV ================//

// ============ PERSISTENT TAGGING FOR ANALYTICS ============

// Build a stable zone key from your candidate (adjust fields if needed)
string ZoneKey(const Candidate &C)
  {
   return StringFormat("%s|%c|%I64d|%.1f|%.1f",
                       TFToStr(C.htf), (C.is_buy?'B':'S'), (long)C.t1, C.top, C.bot);
  }

// ---- keys for terminal global variables (GVs)
string gvPosKey(ulong posId)  { return "ZN|"     + (string)posId;  }
string gvOrdKey(ulong ordId)  { return "ZNORD|"  + (string)ordId;  }

// ---- write/read per-position note
void   TagPosition(ulong posId, const string &note) { GlobalVariableSet(gvPosKey(posId), note); }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string GetTag(ulong posId)
  {
   return GlobalVariableCheck(gvPosKey(posId)) ? GlobalVariableGet(gvPosKey(posId)) : "";
  }


// ---- Build confirmation string for trade info/labels
string BuildConfirmString(const bool &flags[], int kUsed, bool usePairs)
   {
    string s = "";
    string n[7] = {"ENGULF","MFVG","WICK","BOS","SFP","RETEST","IB"};
    int count = 0;
    if(usePairs && Inp_UI_UsePairs)
       {
         // Only show enabled pairs
         struct PairConf { bool enabled; int a; int b; };
         PairConf pairs[6] = {
            {Inp_ConfirmPair1_Enable, (int)Inp_ConfirmPair1_A, (int)Inp_ConfirmPair1_B},
            {Inp_ConfirmPair2_Enable, (int)Inp_ConfirmPair2_A, (int)Inp_ConfirmPair2_B},
            {Inp_ConfirmPair3_Enable, (int)Inp_ConfirmPair3_A, (int)Inp_ConfirmPair3_B},
            {Inp_ConfirmPair4_Enable, (int)Inp_ConfirmPair4_A, (int)Inp_ConfirmPair4_B},
            {Inp_ConfirmPair5_Enable, (int)Inp_ConfirmPair5_A, (int)Inp_ConfirmPair5_B},
            {Inp_ConfirmPair6_Enable, (int)Inp_ConfirmPair6_A, (int)Inp_ConfirmPair6_B}
         };
         for(int i=0;i<6;i++)
            {
             if(!pairs[i].enabled) continue;
             if(flags[pairs[i].a] && flags[pairs[i].b])
                {
                  if(count>0) s+="; ";
                  s += n[pairs[i].a] + " + " + n[pairs[i].b];
                  count++;
                }
            }
         if(count==0)
            {
             // fallback: show individual confirmations that are true
             for(int j=0;j<7;j++)
                {
                  if(flags[j])
                     {
                      if(count>0) s+="; ";
                      s+=n[j];
                      count++;
                     }
                }
            }
       }
    else
       {
         // Only show individual confirmations that are true
         for(int j=0;j<7;j++)
            {
             if(flags[j])
                {
                  if(count>0) s+="; ";
                  s+=n[j];
                  count++;
                }
            }
       }
    return s;
   }

// ---- optional: your own note builder (put whatever you need inside)
string BuildNoteFromCandidate(const Candidate &C, const string &confirmPairs, int kUsed)
   {
    // Add more fields if you want (score, RR, eval TF, etc.)
    return StringFormat("Z=%s|K=%d|Pairs=%s|Score=%.2f", ZoneKey(C), kUsed, confirmPairs, C.score);
   }

// ---- save a note temporarily under the ORDER ticket (called after OrderSend)
void StashNoteForOrder(ulong orderTicket, const string &note)
  {
   if(orderTicket>0)
      GlobalVariableSet(gvOrdKey(orderTicket), note);
  }

// ---- CSV logger

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// (Deal CSV logger removed)


// =================== WEEKEND GUARDS =================== //

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int ServerWeekday() { MqlDateTime dt; TimeToStruct(TimeCurrent(), dt); return (int)dt.day_of_week; }
int ServerHour() { MqlDateTime dt; TimeToStruct(TimeCurrent(), dt); return dt.hour; }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool FridayAfter(const int hourCut) { return (ServerWeekday()==5 && ServerHour()>=hourCut); } // Friday=5
bool WeekendNow() { int d=ServerWeekday(); return (d==6 || d==0); } // Sat=6, Sun=0

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool BlockNewForWeekend()
  {
   if(!Inp_WeekendProtect)
      return false;
   if(WeekendNow())
      return true;
   if(FridayAfter(Inp_Friday_CutoffHour))
      return true;
   // Block trading before Monday 08:00 AM
   if(Inp_MondayProtect)
   {
      if(ServerWeekday()==1 &&  ServerHour() < Inp_Monday_CutoffHour)
      return true;
  }
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ShouldFlattenForWeekend()
  {
   if(!Inp_WeekendProtect)
      return false;
   if(WeekendNow())
      return true;
   if(FridayAfter(Inp_Friday_FlattenHour))
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void FlattenSymbolForWeekend()
  {
   if(!Inp_TradeLive)
      return;
   ConfigureTrade();

// Close positions
   for(int i=PositionsTotal()-1; i>=0; --i)
     {
      ulong pt = PositionGetTicket(i);
      if(pt==0 || !PositionSelectByTicket(pt))
         continue;
      if(PositionGetString(POSITION_SYMBOL)!=_Symbol)
         continue;
      if(!MagicIsOurs((long)PositionGetInteger(POSITION_MAGIC)))
         continue;
      Trade.PositionClose(pt);
      Sleep(50);
     }

// Cancel pendings
   for(int j=OrdersTotal()-1; j>=0; --j)
     {
      ulong ot = OrderGetTicket(j);
      if(ot==0 || !OrderSelect(ot))
         continue;
      if(OrderGetString(ORDER_SYMBOL)!=_Symbol)
         continue;
      if(!MagicIsOurs((long)OrderGetInteger(ORDER_MAGIC)))
         continue;
      Trade.OrderDelete(ot);
      Sleep(20);
     }
  }

// (CSV/text logging utilities removed)

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int PipPoints()
  {
   int d = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   if(d==5 || d==3)
      return 10; // Forex 5-digit (or JPY 3-digit) → 10 points per pip
   return 1;                    // otherwise treat 1 point as a pip-like unit
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
// (Ledger upsert removed)

// ---- MASTER HOOK: attach the note when entry happens; log both entry and exit
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &rq,
                        const MqlTradeResult &rs)
  {
   if(trans.type != TRADE_TRANSACTION_DEAL_ADD)
      return;

   ulong deal   = trans.deal;
   long  et     = (long)HistoryDealGetInteger(deal, DEAL_ENTRY);           // IN / OUT
   string sym   = HistoryDealGetString(deal, DEAL_SYMBOL);
   ulong posId  = (ulong)HistoryDealGetInteger(deal, DEAL_POSITION_ID);
   ulong ordId  = (ulong)HistoryDealGetInteger(deal, DEAL_ORDER);
   ENUM_DEAL_TYPE side = (ENUM_DEAL_TYPE)HistoryDealGetInteger(deal, DEAL_TYPE);
   double price = HistoryDealGetDouble(deal, DEAL_PRICE);
   double sl    = HistoryDealGetDouble(deal, DEAL_SL);
   double tp    = HistoryDealGetDouble(deal, DEAL_TP);
   double pft   = HistoryDealGetDouble(deal, DEAL_PROFIT);
   int    rsn   = (int)HistoryDealGetInteger(deal, DEAL_REASON);           // SL/TP/EXPERT/…
   ulong  mg    = (ulong)HistoryDealGetInteger(deal, DEAL_MAGIC);

// If this is an ENTRY deal, move the note from ORDER → POSITION
   if(et==DEAL_ENTRY_IN)
     {
      if(GlobalVariableCheck(gvOrdKey(ordId)))
        {
         string note = GlobalVariableGet(gvOrdKey(ordId));
         TagPosition(posId, note);             // store under the position id
         GlobalVariableDel(gvOrdKey(ordId));   // cleanup the order stash
        }
      // ops log entry
      OpsLog(StringFormat("DEAL|ENTRY|SYM=%s|SIDE=%s|PRICE=%.*f|SL=%.*f|TP=%.*f|POS=%I64u|ORDER=%I64u",
                          sym, (side==DEAL_TYPE_BUY?"BUY":"SELL"),
                          _Digits, price, _Digits, sl, _Digits, tp, posId, ordId));
     }

// Retrieve the note stored for this position (same for entry & exit)
   string tag = GetTag(posId);

// (Removed CSV logging)

// When the position is closed, drop the GV
   if(et==DEAL_ENTRY_OUT)
      GlobalVariableDel(gvPosKey(posId));

// On exit: we no longer write ledger or CSV; keep only GV cleanup above
   if(et==DEAL_ENTRY_OUT)
     {
      // decode with realized profit
      PrintMagicDecode(mg, pft, true);
      // ops log close with P/L and reason
      OpsLog(StringFormat("DEAL|CLOSE|SYM=%s|SIDE=%s|PRICE=%.*f|SL=%.*f|TP=%.*f|POS=%I64u|PROFIT=%.2f|RSN=%d",
                          sym, (side==DEAL_TYPE_BUY?"BUY":"SELL"),
                          _Digits, price, _Digits, sl, _Digits, tp, posId, pft, rsn));
     }
   else
     {
      // entry: decode basic fields
      PrintMagicDecode(mg);
     }
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
uchar ComputeBOSType(bool is_buy, ENUM_TIMEFRAMES tf, datetime t1)
  {
   bool bBefore=false, bAfter=false;
   double ref=0.0;
   bool ok = HTF_BOS_AroundFVG(tf, t1, is_buy,
                               Inp_HTF_BOS_K, Inp_HTF_BOS_LookbackBars, Inp_HTF_BOS_LookaheadBars,
                               bBefore, bAfter, ref);
   if(!ok)
      return 0;
   if(bBefore && bAfter)
      return 3;
   if(bBefore)
      return 1;
   if(bAfter)
      return 2;
   return 0;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void PrintMagicDecode(const ulong mg, const double profit=0.0, const bool haveProfit=false)
  {
   if(!MagicIsOurs((long)mg))
      return;
   uchar f = MagicFlags(mg);
   uchar p = MagicPair(mg);
   uchar b = MagicBOSType(mg);
   string fl="";
   string names[7] = {"ENG","MFVG","WICK","BOS","SFP","RET","IB"};
   for(int i=0;i<7;i++)
      if((f>>i)&1)
        {
         if(StringLen(fl)>0)
            fl+="+";
         fl+=names[i];
        }
   string bos = (b==3?"BOTH":(b==2?"AFTER":(b==1?"BEFORE":"NONE")));
   string pairS = (p==0?"NA":(string)p);
   if(haveProfit)
      PrintFormat("[MAGIC] decode: BOS=%s | LTF=%s | Pair=%s | Profit=%.2f", bos, (StringLen(fl)>0?fl:"-"), pairS, profit);
   else
      PrintFormat("[MAGIC] decode: BOS=%s | LTF=%s | Pair=%s", bos, (StringLen(fl)>0?fl:"-"), pairS);
  }

//==================== STYLE ====================//
void ApplyChartStyle()
  {
   long chart_id = ChartID();
   ChartSetInteger(chart_id, CHART_COLOR_BACKGROUND, Inp_Color_Background);
   ChartSetInteger(chart_id, CHART_COLOR_FOREGROUND, Inp_Color_Foreground);
   ChartSetInteger(chart_id, CHART_COLOR_GRID,       Inp_Color_Grid);
   ChartSetInteger(chart_id, CHART_COLOR_CANDLE_BULL, Inp_Color_BullCandle);
   ChartSetInteger(chart_id, CHART_COLOR_CANDLE_BEAR, Inp_Color_BearCandle);
   ChartSetInteger(chart_id, CHART_COLOR_CHART_UP,    Inp_Color_BarUp);
   ChartSetInteger(chart_id, CHART_COLOR_CHART_DOWN,  Inp_Color_BarDown);
   ChartSetInteger(chart_id, CHART_COLOR_BID, Inp_Color_BidLine);
   ChartSetInteger(chart_id, CHART_COLOR_ASK, Inp_Color_AskLine);
   ChartSetInteger(chart_id, CHART_MODE, CHART_CANDLES);
   ChartSetInteger(chart_id, CHART_SHOW_GRID, false);
   ChartSetInteger(chart_id, CHART_SHOW_BID_LINE, true);
   ChartSetInteger(chart_id, CHART_SHOW_ASK_LINE, true);
   ChartRedraw();
  }

  
string SideStr(bool is_buy) { return is_buy ? "BUY" : "SELL"; }

// One unified line per event (PLACED / FILLED / BE / TRAIL / CLOSE / ATTACH / ERROR)
void TradeLog(const string phase,
              const Signal &s,
              const double lots,
              const double entry_ref,
              const double sl,
              const double tp,
              const ulong  ticket,
              const string extra)    // put short extras here (e.g., "reason=SL" or "anchor=MFVG(start)")
  {
// Extract FT:Y/N from s.info (kept for history)
   char ft='?';
   int p = StringFind(s.info,"FT:");
   if(p>=0 && p+3<StringLen(s.info))
     {
      int ch = StringGetCharacter(s.info,p+3);
      if(ch=='Y' || ch=='N')
         ft=(char)ch;
     }

// Trim detail to keep line readable
   string detail = s.info;
   if(StringLen(detail)>700)
      detail = StringSubstr(detail,0,700);

   bool usePending = (Inp_EntryMode==Entry_PendingAtEntry) || s.pendingOverride;
   string mode = usePending ? "PEND" : "MKT";
   PrintFormat("[ZERO_TRADE]|PH=%s|TIME=%s|SYM=%s|TF=%s|SIDE=%s|MODE=%s|TICKET=%I64u|LOTS=%.3f|ENTRY=%.*f|SL=%.*f|TP=%.*f|FVG_ID=%s|FVG_LABEL=%s|CONFIRM=%s|FT:%c|ZTF=%s|ZTOP=%.*f|ZBOT=%.*f|ZTIME=%s|%s|DETAIL=%s",
               phase,
               TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES|TIME_SECONDS),
               _Symbol,
               TFToStr(s.htf),
               SideStr(s.is_buy),
               mode,
               ticket,
               lots,
               DigitsSym(), entry_ref,
               DigitsSym(), sl,
               DigitsSym(), (tp>0.0 ? tp : 0.0),
               s.id, s.info, s.confirm, ft,
               TFToStr(s.htf),
               DigitsSym(), s.z_top,
               DigitsSym(), s.z_bot,
               TimeToString(s.z_t1, TIME_DATE|TIME_MINUTES),
               extra,    // short key=value notes
               detail    // the advanced “s.info” line you already build (score, sweep, spread, BOS child, etc.)
              );

// mirror to operations text log (compact)
   OpsLog(StringFormat("ZERO_TRADE|PH=%s|SYM=%s|TF=%s|SIDE=%s|MODE=%s|TICKET=%I64u|LOTS=%.3f|ENTRY=%.*f|SL=%.*f|TP=%.*f|CONF=%s|FT=%c",
                       phase, _Symbol, TFToStr(s.htf), SideStr(s.is_buy),
                       mode,
                       ticket, lots,
                       DigitsSym(), entry_ref,
                       DigitsSym(), sl,
                       DigitsSym(), (tp>0.0 ? tp : 0.0),
                       s.confirm, ft));

// CSV/text logging removed
  }


  ///===========FVG AND TRADE INFO DISPLAY HELPERS ===========///

 int FindZoneIndexBySpec(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1, double top, double bot)
{
   if(g_zone_count<=0) return -1;
   const double eps  = ZoneEps(top, bot);
   const int    tTol = MathMax(PeriodSeconds(tf), 60);

   // precise-ish pass
   for(int i=0;i<g_zone_count;i++){
      const FVGZone z = g_zones[i];          // <-- copy, not reference
      if(z.tf!=tf || z.bullish!=is_buy) continue;
      if(MathAbs((long)(z.t_left - t1)) <= tTol &&
         MathAbs(z.upper - top) <= eps &&
         MathAbs(z.lower - bot) <= eps)
         return i;
   }
   // fallback: overlapping price + broader time tolerance
   for(int i=0;i<g_zone_count;i++){
      const FVGZone z = g_zones[i];          // <-- copy, not reference
      if(z.tf!=tf || z.bullish!=is_buy) continue;
      const double lo=MathMax(z.lower,bot), hi=MathMin(z.upper,top);
      if(hi>lo && MathAbs((long)(z.t_left - t1)) <= 3*PeriodSeconds(tf))
         return i;
   }
   return -1;
}

string BuildOverlayFVGName(ENUM_TIMEFRAMES tf, bool is_buy, datetime t1)
{
   return StringFormat("HTF_%s_FVG_%s_%s",
                       TFToStr(tf),
                       (is_buy?"BUY":"SELL"),
                       TimeToString(t1, TIME_DATE|TIME_MINUTES));
}


//=====================END FVG AND TRADE INFO DISPLAY HELPERS =====================///



//==================== LAST LTF SWING ====================//

// last LTF swing in recent history (uses IsSwingLow/High already in EA)
bool LastLTF_Swing(bool is_buy, int k, double &lvl)
  {
   MqlRates r[];
   int bars;
   if(!CopyRatesTF((ENUM_TIMEFRAMES)_Period, 300, r, bars) || bars< (2*k+5))
      return false;
// series=true => index 1 is last closed bar; scan newest->older
   for(int i=1; i<MathMin(bars-1, 200); ++i)
     {
      if(is_buy && IsSwingLow(r,i,k))
        {
         lvl = r[i].low;
         return true;
        }
      if(!is_buy && IsSwingHigh(r,i,k))
        {
         lvl = r[i].high;
         return true;
        }
     }
   return false;
  }

//==================== CHECK FOR MAX DAILY LOSS HIT ====================//
bool DailyLossHit()
  {
   if(!Inp_UseDailyLossStop)
      return false;

// today (server time)
   MqlDateTime ds;
   TimeToStruct(TimeCurrent(), ds);
   ds.hour=0;
   ds.min=0;
   ds.sec=0;
   datetime dayStart = StructToTime(ds);

// sum today's closed P/L for this symbol + magic
   HistorySelect(dayStart, TimeCurrent());
   double pl=0.0;
   for(int i=HistoryDealsTotal()-1; i>=0; --i)
     {
      ulong deal=HistoryDealGetTicket(i);
      if(HistoryDealGetString(deal, DEAL_SYMBOL)!=_Symbol)
         continue;
      if(!MagicIsOurs((long)HistoryDealGetInteger(deal, DEAL_MAGIC)))
         continue;
      int et=(int)HistoryDealGetInteger(deal, DEAL_ENTRY);
      if(et!=DEAL_ENTRY_OUT)
         continue;                 // only exits
      pl += HistoryDealGetDouble(deal, DEAL_PROFIT);   // includes commission/swap
     }

   double base = AccountInfoDouble(ACCOUNT_BALANCE);
   double limit = -(base * Inp_DailyLossMaxPct/100.0);
   return (pl <= limit);
  }

/// === session filters

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
 bool IsTradingSessionNow()
{
   if(!Inp_UseSessionFilter) return true;

   const datetime now = TimeCurrent();

   // same conversion used for drawing
   MqlDateTime dt; TimeToStruct(now, dt);
   dt.hour=0; dt.min=0; dt.sec=0;
   datetime serverMidnight = StructToTime(dt);
   const int serverTZ  = (int)(TimeCurrent() - TimeGMT());
   const int sessionTZ = Inp_Session_Hours_Are_UTC ? 0 : Inp_Session_TZ_Offset_Hours*3600;

   bool ok=false;

   if(Inp_Session_Allow_London)
   {
      datetime a = serverMidnight + Inp_London_Start_Hour*3600 + (serverTZ - sessionTZ);
      datetime b = serverMidnight + Inp_London_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(b <= a) b += 24*3600;
      ok |= (now >= a && now < b);
   }

   if(Inp_Session_Allow_NY_FirstHalf)
   {
      datetime a = serverMidnight + Inp_NY1_Start_Hour*3600 + (serverTZ - sessionTZ);
      datetime b = serverMidnight + Inp_NY1_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(b <= a) b += 24*3600;
      ok |= (now >= a && now < b);
   }

   if(Inp_Session_Allow_Asia)
   {
      datetime a = serverMidnight + Inp_Asia_Start_Hour*3600 + (serverTZ - sessionTZ);
      datetime b = serverMidnight + Inp_Asia_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(b <= a) b += 24*3600;
      ok |= (now >= a && now < b);
   }

   return ok;
}

 // Returns true iff the timestamp `when` is inside ANY enabled session window.
// Handles UTC vs custom session TZ and windows that wrap past midnight (e.g., 22→02).
bool IsTradingSessionAt(datetime when)
{
   if(!Inp_UseSessionFilter) return true;
   if(when <= 0) when = TimeCurrent();

   // Anchor to the start of *that* day in server time
   MqlDateTime dt; TimeToStruct(when, dt);
   dt.hour = 0; dt.min = 0; dt.sec = 0;
   datetime serverMidnight = StructToTime(dt);

   // Convert session-hours (UTC or custom TZ) to server time
   const int serverTZ  = (int)(TimeCurrent() - TimeGMT());                 // seconds
   const int sessionTZ = (Inp_Session_Hours_Are_UTC ? 0
                         : Inp_Session_TZ_Offset_Hours * 3600);

   // Build the enabled windows (start/end are HOURS in session TZ)
   int starts[3], ends[3], n = 0;
   if(Inp_Session_Allow_London)       { starts[n] = Inp_London_Start_Hour;   ends[n] = Inp_London_End_Hour;   ++n; }
   if(Inp_Session_Allow_NY_FirstHalf) { starts[n] = Inp_NY1_Start_Hour;      ends[n] = Inp_NY1_End_Hour;      ++n; }
   if(Inp_Session_Allow_Asia)         { starts[n] = Inp_Asia_Start_Hour;     ends[n] = Inp_Asia_End_Hour;     ++n; }
   if(n == 0) return true; // no sessions selected -> allow

   // Check `when` against each window
   for(int i=0; i<n; ++i)
   {
      const int sh = starts[i];
      const int eh = ends[i];
      if(sh == eh) continue; // zero-length window; skip

      // Convert window bounds to server time for the "current" day
      datetime a = serverMidnight + sh * 3600 + (serverTZ - sessionTZ);
      datetime b = serverMidnight + eh * 3600 + (serverTZ - sessionTZ);

      if(eh > sh)
      {
         // Simple same-day window [a,b)
         if(when >= a && when < b) return true;
      }
      else
      {
         // Wraps past midnight. There are two valid bindings:
         //  1) Yesterday 22:00 → Today 02:00  (check [a-24h, b))
         //  2) Today     22:00 → Tomorrow 02:00 (check [a, b+24h))
         datetime a_prev = a - 24*3600;
         datetime b_prev = b;
         if(when >= a_prev && when < b_prev) return true;

         datetime b_next = b + 24*3600;
         if(when >= a && when < b_next) return true;
      }
   }
   return false;
}

// =================== SIMPLE NEWS BLOCKER =================== //

int ServerUTCOffsetHours() { return (int)MathRound((double)(TimeCurrent() - TimeGMT())/3600.0); }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ParseDateTime_YMD_HM(const string &s_in, datetime &t_out)
  {
   string s = s_in;
   StringTrimLeft(s);
   StringTrimRight(s);
   int L = StringLen(s);
   if(L < 16)
      return false; // needs YYYY-MM-DD HH:MM

   string ys = StringSubstr(s,0,4);
   string ms = StringSubstr(s,5,2);
   string ds = StringSubstr(s,8,2);
   string hs = StringSubstr(s,11,2);
   string ns = StringSubstr(s,14,2);
   int y = (int)StringToInteger(ys);
   int m = (int)StringToInteger(ms);
   int d = (int)StringToInteger(ds);
   int h = (int)StringToInteger(hs);
   int n = (int)StringToInteger(ns);
   if(y<1970 || m<1 || m>12 || d<1 || d>31 || h<0 || h>23 || n<0 || n>59)
      return false;
   MqlDateTime dt;
   ZeroMemory(dt);
   dt.year=y;
   dt.mon=m;
   dt.day=d;
   dt.hour=h;
   dt.min=n;
   dt.sec=0;
   t_out = StructToTime(dt);
   return (t_out>0);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
datetime ToServerTime(datetime t_input, bool inputUTC, int tzLocalHours)
  {
   int serverUTC_H = ServerUTCOffsetHours();
   if(inputUTC)
      return (t_input + serverUTC_H*3600);
// local hours offset vs UTC
   return (t_input + (tzLocalHours - serverUTC_H)*3600);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void LoadNewsTimes()
  {
   ArrayResize(g_newsTimes,0);

// 1) CSV input list (semicolon-separated)
   if(StringLen(Inp_News_Times_CSV)>0)
     {
      string items[];
      int n = StringSplit(Inp_News_Times_CSV, ';', items);
      for(int i=0;i<n;i++)
        {
         string tok = items[i];
         StringTrimLeft(tok);
         StringTrimRight(tok);
         if(StringLen(tok)==0)
            continue;
         datetime t;
         if(!ParseDateTime_YMD_HM(tok, t))
            continue;
         datetime ts = ToServerTime(t, Inp_News_Times_Are_UTC, Inp_News_TZ_Offset_Hours);
         int k=ArraySize(g_newsTimes);
         ArrayResize(g_newsTimes,k+1);
         g_newsTimes[k]=ts;
        }
     }

// 2) Optional file in MQL5/Files
   int h = FileOpen(Inp_News_FileName, FILE_READ|FILE_TXT|FILE_ANSI|FILE_SHARE_READ);
   if(h!=INVALID_HANDLE)
     {
      while(!FileIsEnding(h))
        {
         string line = FileReadString(h);
         if(StringLen(line)==0)
            continue;
         // take left token before comma if present
         int p = StringFind(line, ",");
         string dtstr = (p>=0? StringSubstr(line,0,p) : line);
         StringTrimLeft(dtstr);
         StringTrimRight(dtstr);
         datetime t;
         if(!ParseDateTime_YMD_HM(dtstr, t))
            continue;
         datetime ts = ToServerTime(t, Inp_News_Times_Are_UTC, Inp_News_TZ_Offset_Hours);
         int k=ArraySize(g_newsTimes);
         ArrayResize(g_newsTimes,k+1);
         g_newsTimes[k]=ts;
        }
      FileClose(h);
     }

// 3) Sort ascending and dedupe near-duplicates within 60s
   int N = ArraySize(g_newsTimes);
   for(int i=0;i<N;i++)
     {
      int best=i;
      for(int j=i+1;j<N;j++)
         if(g_newsTimes[j] < g_newsTimes[best])
            best=j;
      if(best!=i)
        {
         datetime tmp=g_newsTimes[i];
         g_newsTimes[i]=g_newsTimes[best];
         g_newsTimes[best]=tmp;
        }
     }
// dedupe
   if(N>1)
     {
      datetime ded[];
      ArrayResize(ded,0);
      for(int i=0;i<N;i++)
        {
         int dsz = ArraySize(ded);
         if(dsz==0)
           {
            ArrayResize(ded,1);
            ded[0]=g_newsTimes[i];
            continue;
           }
         if(MathAbs((long)(g_newsTimes[i]-ded[dsz-1]))>60)
           {
            ArrayResize(ded,dsz+1);
            ded[dsz]=g_newsTimes[i];
           }
        }
      int dN = ArraySize(ded);
      ArrayResize(g_newsTimes, dN);
      ArrayCopy(g_newsTimes, ded, 0, 0, dN);
     }

   g_newsLoaded = true;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsNewsBlockNow()
  {
   if(!Inp_EnableNewsBlock)
      return false;
   if(!g_newsLoaded)
      LoadNewsTimes();
   int win = MathMax(1, Inp_News_Block_Minutes) * 60;
   datetime now = TimeCurrent();
   for(int i=0;i<ArraySize(g_newsTimes);++i)
      if(MathAbs((long)(now - g_newsTimes[i])) <= win)
         return true;
   return false;
  }




///================= Close Conflict Profitable trades  ===================///

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool IsOppositePositionType(bool new_is_buy, ENUM_POSITION_TYPE ptype)
  {
   return (new_is_buy && ptype==POSITION_TYPE_SELL) ||
          (!new_is_buy && ptype==POSITION_TYPE_BUY);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CloseOppositePositionsIfNeeded(bool new_is_buy)
  {
   if(!Inp_CloseOppositeOnSignal)
      return;

// make sure Trade is configured
   ConfigureTrade();

   int closed=0;

   for(int i=PositionsTotal()-1; i>=0; --i)
     {
      ulong pt = PositionGetTicket(i);
      if(pt==0 || !PositionSelectByTicket(pt))
         continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol)
         continue;
      if(!MagicIsOurs((long)PositionGetInteger(POSITION_MAGIC)))
         continue;

      ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      if(!IsOppositePositionType(new_is_buy, ptype))
         continue;

      double profit = PositionGetDouble(POSITION_PROFIT); // includes swap/commission
      if(Inp_CloseOpp_OnlyIfProfit)
        {
         if(profit < Inp_CloseOpp_MinProfitMoney)
            continue;
        }

      bool ok=false;
      for(int t=0; t<3 && !ok; ++t)
        {
         ok = Trade.PositionClose(pt);     // full close by ticket
         if(!ok)
            Sleep(120);
        }

      if(ok)
        {
         closed++;
         PrintFormat("[ZERO] Closed opposite position %I64u (profit=%.2f) due to new %s signal.",
                     pt, profit, (new_is_buy?"BUY":"SELL"));
        }
      else
        {
         PrintFormat("[ZERO] Failed to close opposite position %I64u: retcode=%u (%s)",
                     pt, Trade.ResultRetcode(), Trade.ResultRetcodeDescription());
        }
     }

   if(closed>0)
      Sleep(150); // tiny pause to let server settle before placing new order
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CancelOppositePendingsIfNeeded(bool new_is_buy)
  {
   if(!Inp_CancelOppositePendings)
      return;

   ConfigureTrade();

   for(int j=OrdersTotal()-1; j>=0; --j)
     {
      ulong ot = OrderGetTicket(j);
      if(ot==0 || !OrderSelect(ot))
         continue;

      if(OrderGetString(ORDER_SYMBOL) != _Symbol)
         continue;
      if(!MagicIsOurs((long)OrderGetInteger(ORDER_MAGIC)))
         continue;

      ENUM_ORDER_TYPE otype = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);

      bool isBuySide  = (otype==ORDER_TYPE_BUY_LIMIT  || otype==ORDER_TYPE_BUY_STOP  || otype==ORDER_TYPE_BUY_STOP_LIMIT);
      bool isSellSide = (otype==ORDER_TYPE_SELL_LIMIT || otype==ORDER_TYPE_SELL_STOP || otype==ORDER_TYPE_SELL_STOP_LIMIT);

      bool isOpp = new_is_buy ? isSellSide : isBuySide;
      if(!isOpp)
         continue;

      bool ok = Trade.OrderDelete(ot);
      if(ok)
         PrintFormat("[ZERO] Canceled opposite pending %I64u due to new %s signal.", ot, (new_is_buy?"BUY":"SELL"));
      else
         PrintFormat("[ZERO] Failed to cancel pending %I64u: retcode=%u (%s)",
                     ot, Trade.ResultRetcode(), Trade.ResultRetcodeDescription());
     }
  }


///===========End Close Conflict Profitable trades  ================///

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string Yn(bool v) { return v?"Y":"N"; }
string Sign2(int v) { return (v>0?"+":(v<0?"-":"0")); }

// Pretty-print all 7 confirmation flags in short form
string BuildFlagsString(const bool &f[])
  {
   string n[7]= {"ENG","MFVG","WICK","BOS","SFP","RET","IB"};
   string s="";
   for(int i=0;i<7;i++)
     {
      if(i)
         s+=" ";
      s += n[i];
      s+="=";
      s+= (f[i] ? "1" : "0");
     }
   return s;
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int WrapLines(const string &text, const int maxChars, string &out[])
  {
   ArrayResize(out,0);
   if(StringLen(text)==0 || maxChars<=8)
      return 0;

   string words[];
   int nw = StringSplit(text, ' ', words);
   string cur="";

   for(int i=0;i<nw;i++)
     {
      string w = words[i];
      if(StringLen(cur)==0)
         cur = w;
      else
         if(StringLen(cur)+1+StringLen(w) <= maxChars)
            cur += " " + w;
         else
           {
            int n=ArraySize(out);
            ArrayResize(out,n+1);
            out[n]=cur;
            cur=w;
           }
     }
   if(StringLen(cur)>0)
     {
      int n=ArraySize(out);
      ArrayResize(out,n+1);
      out[n]=cur;
     }
   return ArraySize(out);
  }



int ConfirmEnumToIndex(EConfirmation c) { return (c==CONF_NONE ? -1 : (int)c); }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string ConfirmIndexToName(int k)
  {
   switch(k)
     {
      case 0:
         return "ENGULF";
      case 1:
         return "MFVG";
      case 2:
         return "WICK";
      case 3:
         return "BOS";
      case 4:
         return "SFP";
      case 5:
         return "RETEST";
      case 6:
         return "IB";
     }
   return "";
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void DebugPanel(const string &txt)
  {

   if(Inp_LogToJournal && !Inp_LogOnlyTrades)
      Print("[ZERO] ", txt);
   if(!Inp_DebugPanel)
      return;

   string name="ZERO_DEBUG";
   if(ObjectFind(0,name)<0)
      ObjectCreate(0,name,OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,name,OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,name,OBJPROP_XDISTANCE,8);
   ObjectSetInteger(0,name,OBJPROP_YDISTANCE,8);
   ObjectSetInteger(0,name,OBJPROP_FONTSIZE,9);
   ObjectSetInteger(0,name,OBJPROP_COLOR,clrSilver);
   ObjectSetString(0,name,OBJPROP_TEXT,txt);

   ChartRedraw();
  }

// --- helper: do we need to update SL/TP? (avoids re-sending for tiny diffs)
bool NeedUpdateSLTP(const double cur, const double want, const double eps)
  {
   if(want==0.0)
      return false;       // nothing requested
   if(cur==0.0)
      return true;        // nothing set yet
   return (MathAbs(cur - want) > eps);
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ConfigureTrade()
  {
   Trade.SetExpertMagicNumber(Inp_Magic);
   Trade.SetDeviationInPoints(10);
   Trade.SetAsyncMode(false);     // ensure calls complete before we read results
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool HasSimilarActiveOrderOrPosition(bool is_buy, double entry)
  {
// tolerate tiny rounding: 5 points or ~1% of ATR on the LTF
   double tol = MathMax(_Point*5.0, ATR(TF_LTF(),14)*0.01);

// --- open positions (one-per-side guard) ---
   if(!Inp_AllowDuplicateSidePositions)
     {
      int ptotal = PositionsTotal();
      for(int i=0; i<ptotal; i++)
        {
         ulong pticket = PositionGetTicket(i);
         if(pticket==0 || !PositionSelectByTicket(pticket))
            continue;

         string sym = PositionGetString(POSITION_SYMBOL);
         if(sym!=_Symbol)
            continue;

         long mg = (long)PositionGetInteger(POSITION_MAGIC);
         if(!MagicIsOurs(mg))
            continue;

         ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         if((is_buy && ptype==POSITION_TYPE_BUY) || (!is_buy && ptype==POSITION_TYPE_SELL))
            return true; // already have a position on this side -> block duplicates
        }
     }

// --- active pending orders (same side & ~same entry) ---
   int ototal = OrdersTotal();
   for(int j=0; j<ototal; j++)
     {
      ulong oticket = OrderGetTicket(j);
      if(oticket==0 || !OrderSelect(oticket))
         continue; // selects from current pool

      string sym = OrderGetString(ORDER_SYMBOL);
      if(sym!=_Symbol)
         continue;

      long mg = (long)OrderGetInteger(ORDER_MAGIC);
      if(!MagicIsOurs(mg))
         continue;

      ENUM_ORDER_TYPE otype = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
      bool sameSide =
         (is_buy && (otype==ORDER_TYPE_BUY_LIMIT || otype==ORDER_TYPE_BUY_STOP)) ||
         (!is_buy && (otype==ORDER_TYPE_SELL_LIMIT || otype==ORDER_TYPE_SELL_STOP));
      if(!sameSide)
         continue;

      double px = OrderGetDouble(ORDER_PRICE_OPEN);
      if(MathAbs(px - entry) <= tol)
         return true; // an order already sits at (roughly) this entry -> block
     }

   return false;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
 
void DrawSessionLines_Today_Simple()
{
   // ---- server midnight (today) ----
   MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
   dt.hour=0; dt.min=0; dt.sec=0;
   datetime serverMidnight = StructToTime(dt);

   // ---- offsets (seconds) ----
   const int serverTZ  = (int)(TimeCurrent() - TimeGMT());                 // server UTC offset (DST-safe)
   const int sessionTZ = Inp_Session_Hours_Are_UTC ? 0 : Inp_Session_TZ_Offset_Hours*3600;

   // --------- LONDON ----------
   if(Inp_Session_Allow_London)
   {
      datetime t1 = serverMidnight + Inp_London_Start_Hour*3600 + (serverTZ - sessionTZ); // FIX: apply (server - session)
      datetime t2 = serverMidnight + Inp_London_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(t2 <= t1) t2 += 24*3600;

      string s1 = "SESSION_LONDON_START", s2 = "SESSION_LONDON_END";
      if(ObjectFind(0,s1)<0) ObjectCreate(0,s1,OBJ_VLINE,0,t1,0); else ObjectMove(0,s1,0,t1,0);
      if(ObjectFind(0,s2)<0) ObjectCreate(0,s2,OBJ_VLINE,0,t2,0); else ObjectMove(0,s2,0,t2,0);
      ObjectSetInteger(0,s1,OBJPROP_COLOR, Inp_SessionColor_London);
      ObjectSetInteger(0,s2,OBJPROP_COLOR, Inp_SessionColor_London);
      ObjectSetInteger(0,s1,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s2,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s1,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s2,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s1,OBJPROP_BACK,true);
      ObjectSetInteger(0,s2,OBJPROP_BACK,true);
   }

   // --------- NY FIRST HALF ----------
   if(Inp_Session_Allow_NY_FirstHalf)
   {
      datetime t1 = serverMidnight + Inp_NY1_Start_Hour*3600 + (serverTZ - sessionTZ);   // FIX
      datetime t2 = serverMidnight + Inp_NY1_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(t2 <= t1) t2 += 24*3600;

      string s1 = "SESSION_NY1_START", s2 = "SESSION_NY1_END";
      if(ObjectFind(0,s1)<0) ObjectCreate(0,s1,OBJ_VLINE,0,t1,0); else ObjectMove(0,s1,0,t1,0);
      if(ObjectFind(0,s2)<0) ObjectCreate(0,s2,OBJ_VLINE,0,t2,0); else ObjectMove(0,s2,0,t2,0);
      ObjectSetInteger(0,s1,OBJPROP_COLOR, Inp_SessionColor_NY1);
      ObjectSetInteger(0,s2,OBJPROP_COLOR, Inp_SessionColor_NY1);
      ObjectSetInteger(0,s1,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s2,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s1,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s2,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s1,OBJPROP_BACK,true);
      ObjectSetInteger(0,s2,OBJPROP_BACK,true);
   }

   // --------- ASIA (optional) ----------
   if(Inp_Session_Allow_Asia)
   {
      datetime t1 = serverMidnight + Inp_Asia_Start_Hour*3600 + (serverTZ - sessionTZ);  // FIX
      datetime t2 = serverMidnight + Inp_Asia_End_Hour  *3600 + (serverTZ - sessionTZ);
      if(t2 <= t1) t2 += 24*3600;

      string s1 = "SESSION_ASIA_START", s2 = "SESSION_ASIA_END";
      if(ObjectFind(0,s1)<0) ObjectCreate(0,s1,OBJ_VLINE,0,t1,0); else ObjectMove(0,s1,0,t1,0);
      if(ObjectFind(0,s2)<0) ObjectCreate(0,s2,OBJ_VLINE,0,t2,0); else ObjectMove(0,s2,0,t2,0);
      ObjectSetInteger(0,s1,OBJPROP_COLOR, Inp_SessionColor_Asia);
      ObjectSetInteger(0,s2,OBJPROP_COLOR, Inp_SessionColor_Asia);
      ObjectSetInteger(0,s1,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s2,OBJPROP_STYLE, Inp_SessionLineStyle);
      ObjectSetInteger(0,s1,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s2,OBJPROP_WIDTH, Inp_SessionLineWidth);
      ObjectSetInteger(0,s1,OBJPROP_BACK,true);
      ObjectSetInteger(0,s2,OBJPROP_BACK,true);
   }
}


// Try different broker filling modes for market orders
bool PlaceMarketWithFallback(bool is_buy,double lots,double sl,double tp,const string &tag)
  {
   ENUM_ORDER_TYPE_FILLING fills[3]= { ORDER_FILLING_FOK, ORDER_FILLING_IOC, ORDER_FILLING_RETURN };
   for(int i=0;i<3;i++)
     {
      Trade.SetTypeFilling(fills[i]);
      bool ok = is_buy ? Trade.Buy(lots,_Symbol,0.0,sl,tp,tag)
                : Trade.Sell(lots,_Symbol,0.0,sl,tp,tag);
      if(ok)
         return true;

      uint rc = Trade.ResultRetcode();
      // If the problem is not about filling/stops/price, trying other fillings likely won't help,
      // but we still iterate through the 3 typical modes for robustness.
      if(rc==TRADE_RETCODE_DONE)
         return true;
     }
   return false;
  }

// Pending orders with expiration handling (no ORDER_TIME_* arg; pass expiration only)

// Pending orders with correct time_type + comment (matches Trade.mqh signature)
bool PlacePendingWithFallback(bool is_buy,
                              double lots,double price,double sl,double tp,
                              datetime exp,const string &comment)
  {
   ENUM_ORDER_TYPE_FILLING fills[3]= { ORDER_FILLING_RETURN, ORDER_FILLING_FOK, ORDER_FILLING_IOC };
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

   for(int i=0;i<3;i++)
     {
      Trade.SetTypeFilling(fills[i]);

      // choose LIMIT vs STOP relative to current price
      bool limitSide = is_buy ? (price<=ask) : (price>=bid);
      ENUM_ORDER_TYPE_TIME ttype = (exp==0 ? ORDER_TIME_GTC : ORDER_TIME_SPECIFIED);

      bool ok;
      if(is_buy)
         ok = limitSide ? Trade.BuyLimit(lots, price, _Symbol, sl, tp, ttype, exp, comment)
              : Trade.BuyStop(lots, price, _Symbol, sl, tp, ttype, exp, comment);
      else
         ok = limitSide ? Trade.SellLimit(lots, price, _Symbol, sl, tp, ttype, exp, comment)
              : Trade.SellStop(lots, price, _Symbol, sl, tp, ttype, exp, comment);

      if(ok)
         return true;

      uint rc = Trade.ResultRetcode();
      // Broker doesn't accept expiration -> retry GTC (no expiration)
      if(rc==TRADE_RETCODE_INVALID_EXPIRATION && exp!=0)
        {
         ttype = ORDER_TIME_GTC;
         exp = 0;
         if(is_buy)
            ok = limitSide ? Trade.BuyLimit(lots, price, _Symbol, sl, tp, ttype, exp, comment)
                 : Trade.BuyStop(lots, price, _Symbol, sl, tp, ttype, exp, comment);
         else
            ok = limitSide ? Trade.SellLimit(lots, price, _Symbol, sl, tp, ttype, exp, comment)
                 : Trade.SellStop(lots, price, _Symbol, sl, tp, ttype, exp, comment);
         if(ok)
            return true;
        }
     }
   return false;
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double LotSizer_One(const double entry, const double sl, bool &hitCapOut)
  {
   hitCapOut = false;

// --- broker spec ---
   double minB  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxB  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double stepB = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(stepB <= 0.0)
      stepB = 0.01;

// --- user caps merged with broker caps ---
   double lo = MathMax(minB, Inp_LotsMin);
   double hi = MathMin(maxB, Inp_LotsMax);
   if(hi < lo)
      hi = lo;

// --- pick raw lots by selected mode ---
   double lotsRaw = 0.0;

   if(Inp_LotMode == Lot_Fixed)
     {
      lotsRaw = Inp_FixedLots;
     }
   else
     {
      // money to risk
      double riskMoney = 0.0;
      if(Inp_LotMode == Lot_RiskPct)
        {
         double base = Inp_RiskUseEquity ? AccountInfoDouble(ACCOUNT_EQUITY)
                       : AccountInfoDouble(ACCOUNT_BALANCE);
         riskMoney = base * (Inp_RiskPerTradePct / 100.0);
        }
      else // Lot_RiskMoney
        {
         riskMoney = Inp_RiskMoney;
        }

      // convert $ risk -> lots using SL distance & contract spec
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double stopDist  = MathMax(MathAbs(entry - sl), tickSize);
      double ticks     = (tickSize > 0.0) ? (stopDist / tickSize) : 0.0;

      if(tickValue <= 0.0 || tickSize <= 0.0 || ticks <= 0.0)
         lotsRaw = lo;  // safe fallback
      else
         lotsRaw = riskMoney / (ticks * tickValue);
     }

// --- round DOWN to broker step so we don't exceed risk when %/$ is used ---
   double lotsStep = MathFloor((lotsRaw + 1e-12) / stepB) * stepB;

// --- clamp to bounds ---
   double lots = lotsStep;
   if(lots < lo)
     {
      lots = lo; /* do not mark as capped -> allow trade at min lot */
     }
   else
      if(lots > hi)
        {
         lots = hi;
         hitCapOut = true;
        }

// normalize precision to step
   int dec = (int)MathMax(0, MathRound(-MathLog10(stepB)));
   lots = NormalizeDouble(lots, dec);

   if(Inp_DebugLotSizing)
      PrintFormat("[ZERO] LotSizer: mode=%d raw=%.6f step=%.6f -> %.6f clamp=[%.4f..%.4f] final=%.4f cap=%s  SL=%.1fpt",
                  (int)Inp_LotMode, lotsRaw, stepB, lotsStep, lo, hi, lots, (hitCapOut?"Y":"N"), MathAbs(entry-sl)/_Point);

   return lots;
  }



// ======= EXECUTOR (final, corrected, with rich journaling) =======
// --- helper: ensure we end up WITH an SL (and TP if requested) or close the trade ---
// Ticket-aware version: when pos_ticket>0, modify that exact position (hedging-safe)
bool EnsureSLTPOrClose(bool is_buy, double wantSL, double wantTP,
                       ulong pos_ticket=0,
                       int max_tries=18, int delay_ms=140)
  {
// repeatedly try to attach/adjust SL/TP; if impossible, close position
   for(int k=0; k<max_tries; ++k)
     {
      // (re)select the position
      bool selected = (pos_ticket>0 ? PositionSelectByTicket(pos_ticket)
                       : PositionSelect(_Symbol));
      if(!selected)
        {
         Sleep(delay_ms);
         continue;
        }

      ENUM_POSITION_TYPE ty=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      bool pos_is_buy = (ty==POSITION_TYPE_BUY);
      if(pos_is_buy!=is_buy)
        {
         // netting: side changed or got netted out; nothing to do
         return true;
        }

      // recompute broker-safe levels vs live ref
      double ref = pos_is_buy ? SymbolInfoDouble(_Symbol,SYMBOL_BID) : SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double sl_des = wantSL;
      double tp_des = wantTP;

      FixStopsToLevels(ref, pos_is_buy, sl_des, tp_des);
      BumpForFreezeLevel(pos_is_buy, sl_des, tp_des);

      double curSL = PositionGetDouble(POSITION_SL);
      double curTP = PositionGetDouble(POSITION_TP);

      // already attached?
      bool sl_ok = (curSL>0.0);
      bool tp_ok = ((tp_des<=0.0) || (curTP>0.0));

      if(sl_ok && tp_ok)
         return true;

      // attempt to modify
      bool mod = (pos_ticket>0)
                 ? Trade.PositionModify(pos_ticket,
                                        (sl_des>0.0 ? ToTick(sl_des) : 0.0),
                                        (tp_des>0.0 ? ToTick(tp_des) : 0.0))
                 : Trade.PositionModify(_Symbol,
                                        (sl_des>0.0 ? ToTick(sl_des) : 0.0),
                                        (tp_des>0.0 ? ToTick(tp_des) : 0.0));
      if(!mod)
        {
         uint rc = Trade.ResultRetcode();
         int  er = GetLastError();
         PrintFormat("[ZERO_GUARD] PositionModify failed rc=%u (%s) err=%d try=%d sl=%.5f tp=%.5f",
                     rc, Trade.ResultRetcodeDescription(), er, k, sl_des, tp_des);

         // tiny nudge if stops too close
         if(rc==TRADE_RETCODE_INVALID_STOPS || rc==TRADE_RETCODE_INVALID_PRICE)
           {
            if(pos_is_buy)
              {
               sl_des -= 2*_Point;
               if(tp_des>0.0)
                  tp_des += 2*_Point;
              }
            else
              {
               sl_des += 2*_Point;
               if(tp_des>0.0)
                  tp_des -= 2*_Point;
              }
           }
        }
      else
        {
         // give server time to apply
         Sleep(delay_ms);
        }
     }

// last check; if still no SL, emergency close
   if((pos_ticket>0 ? PositionSelectByTicket(pos_ticket) : PositionSelect(_Symbol))
      && PositionGetDouble(POSITION_SL)>0.0)
      return true;

   Print("[ZERO_GUARD] Could not attach SL after retries — closing position to avoid naked exposure.");
   bool closed = (pos_ticket>0) ? Trade.PositionClose(pos_ticket) : Trade.PositionClose(_Symbol);
   if(!closed)
     {
      PrintFormat("[ZERO_GUARD] PositionClose failed rc=%u (%s)",
                  Trade.ResultRetcode(), Trade.ResultRetcodeDescription());
     }
   return false;
  }

//==================== ZONE ENGINE ====================//
void DrawOrUpdate(const FVGZone &z)
  {
   if(ObjectFind(0, z.name)==-1)
     {
      ObjectCreate(0, z.name, OBJ_RECTANGLE, 0, z.t_left, z.lower, z.t_right, z.upper);
      ObjectSetInteger(0, z.name, OBJPROP_BACK, true);
      ObjectSetInteger(0, z.name, OBJPROP_FILL, true);
      ObjectSetInteger(0, z.name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, z.name, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, z.name, OBJPROP_ZORDER, 0);
     }
   datetime t2 = Inp_ExtendToRight ? (TimeCurrent() + PeriodSeconds(PERIOD_CURRENT)) : z.t_right;

   ObjectMove(0, z.name, 0, z.t_left, z.lower);
   ObjectMove(0, z.name, 1, t2,       z.upper);

   uint fill = ColorWithAlpha(z.bullish?Inp_BullColor:Inp_BearColor, Inp_FillAlpha);
   ObjectSetInteger(0, z.name, OBJPROP_COLOR, (color)(z.bullish?Inp_BullColor:Inp_BearColor));
   ObjectSetInteger(0, z.name, OBJPROP_BGCOLOR, fill);
   ObjectSetInteger(0, z.name, OBJPROP_STYLE, STYLE_SOLID);
  ObjectSetInteger(0, z.name, OBJPROP_WIDTH, 1);

   if(Inp_ShowMidline)
     {
      if(ObjectFind(0, z.name50)==-1)
        {
         ObjectCreate(0, z.name50, OBJ_TREND, 0, z.t_left, Mid(z.lower,z.upper), t2, Mid(z.lower,z.upper));
         ObjectSetInteger(0, z.name50, OBJPROP_STYLE, STYLE_DOT);
         ObjectSetInteger(0, z.name50, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, z.name50, OBJPROP_SELECTABLE, false);
        }
      ObjectMove(0, z.name50, 0, z.t_left, Mid(z.lower,z.upper));
      ObjectMove(0, z.name50, 1, t2,       Mid(z.lower,z.upper));
      ObjectSetInteger(0, z.name50, OBJPROP_COLOR, (z.bullish?Inp_BullColor:Inp_BearColor));
     }
   else
     {
     if(ObjectFind(0, z.name50)!=-1)
        ObjectDelete(0, z.name50);
     }

// Draw per-zone info label (gap width & momentum) centered in the box
  

// Draw per-zone info label (gap width & momentum)
 // Draw per-zone info label (gap width & momentum)
if(Inp_ShowFVGInfo)
{
   string infoName = z.name + "_INFO";

   // width & momentum
   double w    = MathAbs(z.upper - z.lower);
   double wPts = w/_Point;
   double atr  = ATR(z.tf, Inp_ATR_Period);
   double wATR = (atr>0.0 ? (w/atr) : 0.0);

   double disp = 0.0;
   bool gotDisp = HTF_DisplacementFactor(z.tf, z.t_left, disp);

   string txt = StringFormat("ID:%I64d\n%s\nW:%dpt | W/ATR:%.2f | Disp:%.2f",
                             z.id, z.name, (int)MathRound(wPts), wATR, (gotDisp?disp:0.0));

   // ---- keep label centered INSIDE the original box (no extend jitter)
   datetime t_left  = z.t_left;
   datetime t_right = z.t_right;

   // Visible-window clamp so it never "vanishes" off-screen
   int firstVis = (int)ChartGetInteger(0, CHART_FIRST_VISIBLE_BAR);
   int visCount = (int)ChartGetInteger(0, CHART_VISIBLE_BARS);
   int rightIdx = MathMax(0, firstVis - (visCount - 1));
   datetime rightVis = iTime(_Symbol, (ENUM_TIMEFRAMES)Period(), rightIdx);
   if(rightVis>0 && t_right > rightVis) t_right = rightVis;

   long tc = (long)t_left + ((long)t_right - (long)t_left)/2;
   datetime tx = (datetime)tc;

   // y at mid of zone (always inside while zone is valid)
   double y = (z.lower + z.upper) * 0.5;

   // Remove any previous multi-line info labels
   for(int i=0;i<10;i++) {
      string infoLine = infoName + StringFormat("_%d", i);
      if(ObjectFind(0, infoLine) >= 0) ObjectDelete(0, infoLine);
   }
   // Split txt into lines
   string lines[];
   int nLines = StringSplit(txt, '\n', lines);
   for(int i=0; i<nLines; ++i) {
      string infoLine = infoName + StringFormat("_%d", i);
      double yLine = y + (i - nLines/2.0) * Inp_LabelLineStepPoints * _Point;
      if(ObjectFind(0, infoLine) < 0)
         ObjectCreate(0, infoLine, OBJ_TEXT, 0, tx, yLine);
      else
         ObjectMove(0, infoLine, 0, tx, yLine);
      ObjectSetString (0, infoLine, OBJPROP_TEXT, lines[i]);
      ObjectSetInteger(0, infoLine, OBJPROP_COLOR, (long)Inp_Color_Foreground);
      ObjectSetInteger(0, infoLine, OBJPROP_FONTSIZE, Inp_FVGInfoFontSize);
      ObjectSetInteger(0, infoLine, OBJPROP_BACK, false);
      ObjectSetInteger(0, infoLine, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, infoLine, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, infoLine, OBJPROP_ANCHOR, ANCHOR_CENTER);
      ObjectSetInteger(0, infoLine, OBJPROP_ZORDER, 2000);
   }
}
else
{
   // Remove all possible multi-line info labels
   string infoName = z.name + "_INFO";
   for(int i=0;i<10;i++) {
      string infoLine = infoName + StringFormat("_%d", i);
      if(ObjectFind(0, infoLine) >= 0) ObjectDelete(0, infoLine);
   }
}
ChartRedraw();
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void DeleteZoneGraphics(const FVGZone &z)
  {
   if(ObjectFind(0, z.name)!=-1)
      ObjectDelete(0, z.name);
   if(ObjectFind(0, z.name50)!=-1)
      ObjectDelete(0, z.name50);
   string infoName = z.name + "_INFO";
   if(ObjectFind(0, infoName)!=-1)
      ObjectDelete(0, infoName);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void AddZone(FVGZone &z)
  {
   z.id    = g_next_id++;
   z.name  = StringFormat("%s_%s_%s_%I64d", Inp_ObjectPrefix, _Symbol, TFToStr(z.tf), z.id);
   z.name50= StringFormat("%s_MID_%s_%s_%I64d", Inp_ObjectPrefix, _Symbol, TFToStr(z.tf), z.id);
   z.active= true;
   z.created= TimeCurrent();

   int tfcount=0;
   for(int i=0;i<g_zone_count;i++)
      if(g_zones[i].tf==z.tf)
         tfcount++;
   if(tfcount>=Inp_MaxZonesPerTF)
     {
      int oldest=-1;
      datetime t_oldest=D'3000.01.01';
      for(int i=0;i<g_zone_count;i++)
         if(g_zones[i].tf==z.tf)
            if(g_zones[i].created<t_oldest)
              {
               t_oldest=g_zones[i].created;
               oldest=i;
              }
      if(oldest>=0)
        {
         DeleteZoneGraphics(g_zones[oldest]);
         for(int k=oldest;k<g_zone_count-1;k++)
            g_zones[k]=g_zones[k+1];
         g_zone_count--;
         ArrayResize(g_zones, g_zone_count);
        }
     }
   ArrayResize(g_zones, g_zone_count+1);
   g_zones[g_zone_count]=z;
   g_zone_count++;
   DrawOrUpdate(z);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool OverlapSameSide(const FVGZone &a, const FVGZone &b)
  {
   if(a.tf!=b.tf)
      return false;
   if(a.bullish!=b.bullish)
      return false;
   if(a.upper < b.lower || b.upper < a.lower)
      return false;
   return true;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void TryMergeNewIntoExisting(FVGZone &nz)
  {
   if(!Inp_MergeOverlaps)
     {
      AddZone(nz);
      return;
     }
   for(int i=0;i<g_zone_count;i++)
     {
      if(!g_zones[i].active)
         continue;
      if(OverlapSameSide(g_zones[i], nz))
        {
         g_zones[i].lower  = MathMin(g_zones[i].lower,  nz.lower);
         g_zones[i].upper  = MathMax(g_zones[i].upper,  nz.upper);
         g_zones[i].t_left = (g_zones[i].t_left<=nz.t_left)? g_zones[i].t_left : nz.t_left;
         g_zones[i].t_right= (g_zones[i].t_right>=nz.t_right)? g_zones[i].t_right : nz.t_right;
         DrawOrUpdate(g_zones[i]);
         return;
        }
     }
   AddZone(nz);
  }

//==================== ATR & FILTERS ====================//
double ATR(ENUM_TIMEFRAMES tf, int period)
  {
   int handle = iATR(_Symbol, tf, period);
   if(handle==INVALID_HANDLE)
      return 0.0;
   double buf[];
   if(CopyBuffer(handle, 0, 1, 1, buf)!=1)
     {
      IndicatorRelease(handle);
      return 0.0;
     }
   IndicatorRelease(handle);
   return buf[0];
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool PassesSizeFilter(ENUM_TIMEFRAMES tf, double lower, double upper)
  {
   double size = upper-lower;
   if(size/_Point < Inp_MinPoints)
      return false;
   if(Inp_UseATRFilter)
     {
      double atr = ATR(tf, Inp_ATR_Period);
      if(atr<=0)
         return false;
      if(size < atr*Inp_ATR_Mult)
         return false;
     }
   return true;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool NewBarOccurred(ENUM_TIMEFRAMES tf, datetime &last_known)
  {
   datetime t[3];
   int n=CopyTime(_Symbol, tf, 0, 2, t);
   if(n<2)
      return false;
   datetime prevClosed = t[1];
   if(prevClosed!=last_known)
     {
      last_known = prevClosed;
      return true;
     }
   return false;
  }
